<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flash Cards App</title>
    <style>
        :root {
            --background-color: #ffffff;
            --text-color: #333333;
            --card-background: #f9f9f9;
            --card-border: #dddddd;
            --button-background: #007bff;
            --button-text: #ffffff;
            --button-background-hover: #0056b3;
            --learned-button: #28a745;
            --learned-button-hover: #218838;
            --review-button: #dc3545;
            --review-button-hover: #c82333;
            --reset-button: #6c757d; /* Цвет для кнопки сброса */
            --reset-button-hover: #5a6268;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --overlay-background: rgba(0, 0, 0, 0.5);
            --modal-background: #ffffff;
            --modal-text: #333333;
        }

        body.dark-mode {
            --background-color: #1e1e1e;
            --text-color: #f0f0f0; /* Светлый текст */
            --card-background: #333333; /* Темный фон карточки */
            --card-border: #555555;
            --button-background: #0056b3;
            --button-text: #ffffff;
            --button-background-hover: #003f80;
            --learned-button: #218838;
            --learned-button-hover: #1e7e34;
            --review-button: #c82333;
            --review-button-hover: #bd2130;
            --reset-button: #5a6268;
            --reset-button-hover: #6c757d;
            --shadow-color: rgba(255, 255, 255, 0.1);
            --overlay-background: rgba(0, 0, 0, 0.7);
            --modal-background: #333333;
            --modal-text: #f0f0f0;
        }

        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px; /* Общий отступ по краям */
            background-color: var(--background-color);
            color: var(--text-color); /* Наследуется для всего текста по умолчанию */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.3s ease, color 0.3s ease;
            box-sizing: border-box; /* Учитываем padding в общей ширине */
            overflow-y: auto; /* Позволяет прокручивать страницу, если контент не помещается */
        }

        header {
            text-align: center;
            margin-top: 5px; /* Расстояние от верхнего края экрана (от inner padding body) */
            margin-bottom: 5px; /* Расстояние до плашки */
            width: 100%;
            max-width: 600px;
            display: flex; /* Используем Flexbox */
            flex-direction: row; /* Элементы в строку по умолчанию */
            flex-wrap: wrap; /* Разрешаем перенос строки на маленьких экранах */
            align-items: center; /* Выравнивание по центру по вертикали */
            justify-content: center; /* Центрируем группу элементов в строке */
            gap: 10px; /* Промежуток в 10px между прямыми потомками header (h1 и .header-stats-timer) по горизонтали */
            /* gap применяется ко всем промежуткам, включая вертикальные при wrap */
            padding: 0 10px; /* Отступ по бокам */
            box-sizing: border-box;
        }


        header h1 {
            color: var(--text-color);
            margin: 0; /* Убираем margin */
            font-size: 12px; /* Размер шрифта заголовка 12px */
            flex-grow: 0; /* Заголовок не занимает все доступное пространство */
            flex-shrink: 1; /* Позволяем ему сжиматься */
            text-align: center; /* Центрируем текст заголовка */
            min-width: 100px; /* Минимальная ширина */
        }

         /* Группа статистики и таймера */
         .header-stats-timer {
             display: flex;
             align-items: center;
             gap: 10px; /* Промежуток между статсами и таймером */
             flex-wrap: nowrap; /* Предотвращаем перенос внутри группы */
             flex-shrink: 0; /* Не сжимаем группу сильно */
             min-width: auto; /* Ширина определяется содержимым */
         }

         #card-counts {
             font-size: 1rem; /* Размер шрифта статистики */
             color: var(--text-color);
             white-space: nowrap; /* Предотвращаем перенос текста статистики */
             flex-shrink: 1; /* Разрешаем сжиматься */
             min-width: 0; /* Позволяем сжиматься меньше содержимого */
             text-overflow: ellipsis; /* Добавляем многоточие */
             overflow: hidden; /* Скрываем вылезающий текст */
         }

        #timer {
             font-size: 1.2rem; /* Размер шрифта таймера */
             font-weight: bold;
             color: var(--text-color);
             white-space: nowrap; /* Предотвращаем перенос текста таймера */
             flex-shrink: 0; /* Не сжимаем таймер сильно */
             min-width: auto; /* Ширина определяется содержимым */
         }

         /* Стили для кнопок в хедере (их нет в этой версии) */


        main {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-grow: 1; /* Занимает доступное пространство */
            justify-content: center; /* Центрируем контент по вертикали */
            padding-bottom: 80px; /* Отступ снизу для кнопок управления внизу */
        }

        .card-container {
            width: 100%;
            perspective: 1000px; /* Для 3D эффекта переворота */
            margin-bottom: 20px;
            max-width: 400px; /* Ограничение ширины карточки */
            height: 455px; /* Увеличена высота плашки на 30% от 350px */
            flex-shrink: 0; /* Не сжимается */
        }

        .flashcard {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1); /* Плавный переход */
            box-shadow: 0 4px 8px var(--shadow-color);
            border-radius: 10px;
            background-color: var(--card-background); /* Фон карточки */
            border: 1px solid var(--card-border);
            cursor: pointer; /* Показываем, что карточка кликабельна */
        }

        .flashcard.is-flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Скрываем обратную сторону */
            /* === Используем Flexbox для центрирования содержимого === */
            display: flex;
            flex-direction: column; /* Располагаем элементы вертикально */
            justify-content: center; /* Центрируем содержимое вертикально */
            align-items: center; /* Центрируем содержимое горизонтально */
            padding: 20px;
            text-align: center; /* Выравнивание текста по центру внутри блока */
            border-radius: 10px;
            overflow: hidden; /* Скрываем вылезающий контент */
            box-sizing: border-box; /* Учитываем padding в размере */
             color: var(--text-color); /* Явно указываем цвет текста карточки */
        }

        .card-front {
            z-index: 2;
            transform: rotateY(0deg);
        }

        .card-back {
            transform: rotateY(180deg);
            justify-content: space-between; /* Разносим текст и кнопки */
            padding-bottom: 80px; /* Отступ для кнопок внизу */
            /* box-sizing: border-box; already set in .card-face */
        }

        .card-text {
            font-size: 1.5rem; /* Крупный шрифт */
            margin: 0; /* Убираем стандартные margin */
            overflow-y: auto; /* Добавляем прокрутку, если текст длинный */
            word-break: break-word; /* Перенос длинных слов */
            padding: 10px 0; /* Небольшой вертикальный отступ */
            width: 100%; /* Занимает всю доступную ширину */
             flex-grow: 1; /* Позволяет тексту занимать доступное пространство */
             /* color: var(--text-color); Inherited from .card-face */
        }
         .card-back .card-text {
             margin-bottom: 20px; /* Отступ между текстом и кнопками на обратной стороне */
              flex-grow: 0; /* Текст не должен занимать все место, чтобы оставить место кнопкам */
              max-height: calc(100% - 60px); /* Грубая оценка высоты, чтобы кнопки поместились */
         }


        .card-actions {
            position: absolute; /* Позиционируем абсолютно */
            bottom: 20px; /* Прижимаем к низу */
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px; /* Промежуток между кнопками */
            padding: 0 20px;
            box-sizing: border-box;
            flex-shrink: 0;
            flex-wrap: nowrap; /* <<< Главное: предотвращаем перенос кнопок действий */
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            transition: background-color 0.2s ease;
            background-color: var(--button-background);
            color: var(--button-text); /* Цвет текста на кнопках */
        }

        button:hover {
            background-color: var(--button-background-hover);
        }

        .action-button {
             flex-grow: 1; /* Кнопки действий занимают равное пространство */
             max-width: 112.5px; /* <<< Уменьшена максимальная ширина на 25% (150 * 0.75) */
             flex-shrink: 0; /* <<< Не сжимаются меньше минимального размера */
             min-width: 60px; /* <<< Задаем минимальную ширину, чтобы текст был читаемым */
             box-sizing: border-box; /* Учитываем padding в ширине */
             /* Убраны flex-basis: auto и max-width: none из @media - они не нужны при nowrap */
        }

        .action-button.learned {
            background-color: var(--learned-button);
        }
        .action-button.learned:hover {
            background-color: var(--learned-button-hover);
        }

        .action-button.review {
            background-color: var(--review-button);
        }
        .action-button.review:hover {
            background-color: var(--review-button-hover);
        }


        .navigation, .controls {
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap; /* Перенос кнопок на маленьких экранах */
        }

        .navigation button, .controls button {
             flex-basis: 150px; /* Минимальная ширина кнопок навигации/контроля */
             flex-grow: 1; /* Позволяем растягиваться */
             max-width: 200px; /* Максимальная ширина */
        }

         /* Стили для кнопок в controls, их стало 5 */
         .controls button {
             flex-basis: 100px; /* Скорректируем базовую ширину для 5 кнопок */
             flex-grow: 1;
             max-width: 150px; /* Скорректируем макс ширину */
             font-size: 0.9rem; /* Слегка уменьшим шрифт */
             padding: 8px 12px; /* Слегка уменьшим padding */
             white-space: nowrap; /* Предотвращаем перенос текста внутри кнопок */
         }

        #reset-app {
            background-color: var(--reset-button); /* Применяем цвет сброса к кнопке в controls */
        }
         #reset-app:hover {
            background-color: var(--reset-button-hover);
        }


        .stats-area {
            margin-top: 30px;
            padding: 20px;
            border: 1px solid var(--card-border);
            border-radius: 10px;
            background-color: var(--card-background); /* Фон статистики */
            width: 100%;
            max-width: 600px;
            text-align: center;
             color: var(--text-color); /* Цвет текста статистики */
        }

        /* Модальное окно завершения */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--overlay-background);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Поверх всего остального */
            visibility: hidden; /* Скрыто по умолчанию */
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.visible {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background: var(--modal-background);
            color: var(--modal-text); /* Цвет текста в модальном окне */
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 90%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }

        .modal-content h2 {
            margin-top: 0;
            color: var(--modal-text); /* Цвет заголовка в модальном окне */
        }

        .modal-content button {
            margin-top: 20px;
        }


        /* Responsive adjustments */
        @media (max-width: 600px) {
             /* Header позволяет перенос строки */
             header {
                 flex-direction: column; /* Элементы в колонку на маленьких экранах */
                 gap: 5px; /* Расстояние 5px между элементами при вертикальном стеке */
                 padding: 0 10px;
                 align-items: stretch; /* Растягиваем элементы */
             }

             header h1 {
                  font-size: 12px; /* Размер заголовка 12px на мобильном тоже */
                  text-align: center;
                  width: 100%; /* Занимает всю ширину */
                  min-width: auto; /* Сбрасываем минимальную ширину */
             }

             .header-stats-timer {
                 flex-wrap: wrap; /* Разрешаем перенос внутри группы */
                 justify-content: center; /* Центрируем группу, когда она сама перенесена */
                 width: 100%; /* Занимает всю ширину */
                 gap: 10px; /* Расстояние между статсами и таймером внутри группы */
             }

             #card-counts, #timer {
                 font-size: 0.9rem; /* Уменьшаем шрифт */
                 text-align: center;
                 flex-shrink: 1;
                 min-width: auto; /* Сбрасываем мин ширину */
                 width: auto; /* Ширина по содержимому */
             }

             /* Adjust main padding */
             main {
                 padding-top: 5px; /* Расстояние 5px после хедера на мобильном */
             }


            .card-container {
                 height: 450px; /* Увеличена высота плашки на 30% от 300px на мобильном */
                 max-width: 100%;
            }

            .card-text {
                font-size: 1.3rem;
            }

            button {
                padding: 8px 15px;
                font-size: 0.9rem;
            }

             /* Controls остаются с переносом */
             .navigation button, .controls button {
                 flex-basis: auto;
                 flex-grow: 1;
                 max-width: none;
             }

             .card-actions {
                 flex-direction: row; /* <<< Фиксируем в строку даже на мобильных */
                 flex-wrap: nowrap; /* <<< Отключаем перенос */
                 gap: 10px; /* Уменьшаем промежуток между кнопками действий */
                 bottom: 10px;
                 justify-content: center; /* Центрируем кнопки в строке */
                 padding: 0 10px; /* Adjust padding */
             }

             .action-button {
                  max-width: 112.5px; /* <<< Сохраняем уменьшенную макс ширину */
                  min-width: 60px; /* <<< Сохраняем мин ширину */
                  flex-grow: 1; /* Позволяем им делиться пространством */
                  flex-shrink: 0; /* Не сжимаются меньше мин ширины */
                  padding: 8px 10px; /* Уменьшаем padding */
                  font-size: 0.8rem; /* Уменьшаем шрифт */
             }


             .card-back {
                 padding-bottom: 110px;
             }

             .modal-content {
                 padding: 20px;
             }
        }


        /* Accessibility (basic keyboard focus indication) */
        button:focus-visible {
            outline: 2px solid var(--button-background-hover);
            outline-offset: 2px;
        }
         #reset-app:focus-visible {
            outline-color: var(--reset-button-hover);
         }
         .modal-content button:focus-visible {
             outline-color: var(--button-background-hover); /* Или другой цвет для модальной кнопки */
         }
    </style>
</head>
<body class="dark-mode"> <header>
        <h1>A/B TESTS</h1> <div class="header-stats-timer"> <div id="card-counts">И: 0, П: 0, В: 0</div>
            <div id="timer">00:00</div>
        </div>
        </header>

    <main>
        <div class="card-container">
            <div class="flashcard" id="flashcard">
                <div class="card-face card-front">
                    <p class="card-text" id="card-front-text"></p>
                </div>
                <div class="card-face card-back">
                    <p class="card-text" id="card-back-text"></p>
                    <div class="card-actions">
                        <button class="action-button learned" data-status="learned">Изучено</button>
                        <button class="action-button review" data-status="review">Повторить</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="navigation">
            <button id="prev-card">&laquo; Назад</button>
            <button id="next-card">&raquo; Вперед</button>
        </div>

        <div class="controls">
            <button id="shuffle-cards">Перемешать</button> <button id="toggle-review-mode">Повторить (0)</button> <button id="toggle-stats">Показать статистику</button>
             <button id="theme-toggle">Сменить тему</button>
             <button id="reset-app">Сброс</button> </div>

        <div class="stats-area" id="stats-area">
            <h2>Статистика</h2>
            <p>Всего карточек: <span id="total-cards-stats">0</span></p>
            <p>Изучено: <span id="learned-stats">0</span></p>
            <p>Требуют повторения: <span id="review-stats">0</span></p>
            <p>Просмотрено: <span id="seen-stats">0</span></p>
             </div>
    </main>

    <div class="modal-overlay" id="completion-modal">
        <div class="modal-content">
            <h2>Поздравляем!</h2>
            <p>Вы изучили все карточки!</p>
             <p>Ваше время: <span id="final-time">00:00</span></p>
            <button id="start-over-button">Начать заново</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const flashcard = document.getElementById('flashcard');
            const cardFrontText = document.getElementById('card-front-text');
            const cardBackText = document.getElementById('card-back-text');
            const prevButton = document.getElementById('prev-card');
            const nextButton = document.getElementById('next-card');
            const shuffleButton = document.getElementById('shuffle-cards'); // Теперь внизу
            const toggleReviewModeButton = document.getElementById('toggle-review-mode'); // Теперь внизу
            const themeToggleButton = document.getElementById('theme-toggle'); // Внизу
            const actionButtons = document.querySelectorAll('.card-actions .action-button');
            const toggleStatsButton = document.getElementById('toggle-stats');
            const statsArea = document.getElementById('stats-area');
            const totalCardsStats = document.getElementById('total-cards-stats');
            const learnedStats = document.getElementById('learned-stats');
            const reviewStats = document.getElementById('review-stats');
            const seenStats = document.getElementById('seen-stats');
            const timerDisplay = document.getElementById('timer');
            const completionModal = document.getElementById('completion-modal');
            const startOverButton = document.getElementById('start-over-button');
            const finalTimeDisplay = document.getElementById('final-time');
            const resetAppButton = document.getElementById('reset-app'); // Теперь внизу
            const cardCountsDisplay = document.getElementById('card-counts'); // Вверху


            // --- Sample Data ---
            // Статусы сбрасываются при каждой загрузке, т.к. нет сохранения
            let cards = [


    { id: 'card-1', front: 'Что такое A/B-тестирование?', back: 'Метод сравнения двух версий чего-либо (например, веб-страницы) для определения, какая из них работает лучше.', status: 'unseen' },
    { id: 'card-2', front: 'Какие основные цели A/B-тестирования?', back: 'Улучшение ключевых показателей (конверсия, кликабельность, продажи), снижение рисков при внедрении изменений, принятие решений на основе данных.', status: 'unseen' },
    { id: 'card-3', front: 'Что такое контрольная группа в A/B-тесте?', back: 'Группа пользователей, которой показывают текущую (старую) версию.', status: 'unseen' },
    { id: 'card-4', front: 'Что такое тестовая группа в A/B-тесте?', back: 'Группа пользователей, которой показывают новую (экспериментальную) версию.', status: 'unseen' },
    { id: 'card-5', front: 'Что такое статистическая значимость?', back: 'Вероятность того, что разница в результатах между группами не случайна.', status: 'unseen' },
    { id: 'card-6', front: 'Какие типы данных используются в A/B-тестах?', back: 'Бинарные (успех/неудача) и непрерывные (числовые значения).', status: 'unseen' },
    { id: 'card-7', front: 'Какие тесты используют для бинарных данных?', back: 'Z-тест для пропорций, критерий хи-квадрат Пирсона, точный тест Фишера.', status: 'unseen' },
    { id: 'card-8', front: 'Какие тесты используют для непрерывных данных?', back: 't-тест Стьюдента (для нормального распределения), тест Манна-Уитни (для ненормального распределения).', status: 'unseen' },
    { id: 'card-9', front: 'Когда используют Z-тест для пропорций?', back: 'Для больших выборок, где количество успехов и неудач в каждой группе не менее 5-10.', status: 'unseen' },
    { id: 'card-10', front: 'Когда используют точный тест Фишера?', back: 'Для малых выборок, когда ожидаемые частоты в таблице сопряженности меньше 5.', status: 'unseen' },
    { id: 'card-11', front: 'Что такое p-value?', back: 'Вероятность получить наблюдаемую разницу (или более экстремальную) при условии, что нулевая гипотеза верна.', status: 'unseen' },
    { id: 'card-12', front: 'Как интерпретировать p-value?', back: 'Если p-value < 0.05, разница статистически значима; если p-value ≥ 0.05, разница незначима.', status: 'unseen' },
    { id: 'card-13', front: 'Что такое доверительный интервал?', back: 'Диапазон значений, в котором с определенной вероятностью находится истинное значение метрики.', status: 'unseen' },
    { id: 'card-14', front: 'Что такое минимальный детектируемый эффект (MDE)?', back: 'Наименьший размер эффекта, который мы хотим обнаружить с заданной мощностью теста.', status: 'unseen' },
    { id: 'card-15', front: 'Что такое мощность теста?', back: 'Вероятность правильно обнаружить статистически значимую разницу, если она существует.', status: 'unseen' },
    { id: 'card-16', front: 'Какие факторы влияют на размер выборки?', back: 'Базовая конверсия, MDE, уровень значимости (α), мощность теста (1-β).', status: 'unseen' },
    { id: 'card-17', front: 'Как избежать проблемы "подглядывания" (peeking)?', back: 'Не останавливать тест раньше времени, дождаться запланированного размера выборки.', status: 'unseen' },
    { id: 'card-18', front: 'Что такое эффект новизны?', back: 'Пользователи могут реагировать на изменения только потому, что они новые, а не потому, что они лучше.', status: 'unseen' },
    { id: 'card-19', front: 'Что такое A/A-тестирование?', back: 'Тест, где обе группы видят одинаковую версию, используется для проверки корректности системы.', status: 'unseen' },
    { id: 'card-20', front: 'Какие метрики часто используют в A/B-тестах?', back: 'Коэффициент конверсии, CTR, показатель отказов, время на странице, средний чек.', status: 'unseen' },
    { id: 'card-21', front: 'Как рассчитать коэффициент конверсии?', back: '(Количество конверсий / Общее количество посетителей) * 100%.', status: 'unseen' },
    { id: 'card-22', front: 'Как рассчитать CTR?', back: '(Количество кликов / Количество показов элемента) * 100%.', status: 'unseen' },
    { id: 'card-23', front: 'Как рассчитать показатель отказов?', back: '(Количество сеансов с одной страницей / Общее количество сеансов) * 100%.', status: 'unseen' },
    { id: 'card-24', front: 'Что такое нулевая гипотеза (H0)?', back: 'Гипотеза об отсутствии значимых различий между группами.', status: 'unseen' },
    { id: 'card-25', front: 'Что такое альтернативная гипотеза (H1)?', back: 'Гипотеза о наличии значимых различий между группами.', status: 'unseen' },
    { id: 'card-26', front: 'Как сформулировать гипотезу для A/B-теста?', back: 'Если мы изменим [элемент], то [метрика] изменится [определенным образом].', status: 'unseen' },
    { id: 'card-27', front: 'Почему важно тестировать одну переменную за раз?', back: 'Чтобы точно определить, какое изменение повлияло на результат.', status: 'unseen' },
    { id: 'card-28', front: 'Как выбрать целевую аудиторию для теста?', back: 'Определить сегмент пользователей (например, новые или вернувшиеся) или тестировать на всех.', status: 'unseen' },
    { id: 'card-29', front: 'Как рассчитать продолжительность теста?', back: 'Учитывать размер выборки, недельные циклы, сезонность и достижение необходимого трафика.', status: 'unseen' },
    { id: 'card-30', front: 'Почему важна рандомизация в A/B-тестах?', back: 'Чтобы минимизировать систематические ошибки и обеспечить репрезентативность выборок.', status: 'unseen' },
    { id: 'card-31', front: 'Какие Python-библиотеки используют для A/B-тестов?', back: 'scipy.stats, statsmodels, numpy, pandas.', status: 'unseen' },
    { id: 'card-32', front: 'Как провести Z-тест для пропорций в Python?', back: 'Использовать функцию proportions_ztest из statsmodels.stats.proportion.', status: 'unseen' },
    { id: 'card-33', front: 'Как провести t-тест в Python?', back: 'Использовать функцию ttest_ind из scipy.stats.', status: 'unseen' },
    { id: 'card-34', front: 'Как провести критерий хи-квадрат в Python?', back: 'Использовать функцию chi2_contingency из scipy.stats.', status: 'unseen' },
    { id: 'card-35', front: 'Как провести точный тест Фишера в Python?', back: 'Использовать функцию fisher_exact из scipy.stats.', status: 'unseen' },
    { id: 'card-36', front: 'Как смоделировать данные для A/B-теста в Python?', back: 'Использовать numpy.random.binomial для бинарных данных или numpy.random.normal для непрерывных.', status: 'unseen' },
    { id: 'card-37', front: 'Что такое байесовское A/B-тестирование?', back: 'Подход, который обновляет убеждения о эффективности вариантов на основе априорных знаний и данных.', status: 'unseen' },
    { id: 'card-38', front: 'Что такое дилемма исследования и использования (Explore-Exploit)?', back: 'Компромисс между исследованием новых вариантов и использованием лучшего известного варианта.', status: 'unseen' },
    { id: 'card-39', front: 'Что такое алгоритм ε-greedy?', back: 'Алгоритм, который с вероятностью 1-ε выбирает лучший вариант, а с вероятностью ε — случайный.', status: 'unseen' },
    { id: 'card-40', front: 'Что такое алгоритм UCB1?', back: 'Алгоритм, который выбирает вариант с наибольшей верхней границей доверительного интервала.', status: 'unseen' },
    { id: 'card-41', front: 'Как работает алгоритм UCB1?', back: 'UCB = средняя награда + c * √(ln(t) / n), где c — параметр, t — общее число итераций, n — число выборов варианта.', status: 'unseen' },
    { id: 'card-42', front: 'Что такое Thompson Sampling?', back: 'Байесовский алгоритм, который выбирает вариант на основе случайной выборки из распределения вероятностей.', status: 'unseen' },
    { id: 'card-43', front: 'Как работает Thompson Sampling?', back: 'Для каждого варианта генерируется случайное значение из его распределения, выбирается вариант с наибольшим значением.', status: 'unseen' },
    { id: 'card-44', front: 'Какое распределение используют в Thompson Sampling для бинарных данных?', back: 'Бета-распределение (Beta(α, β)), где α — успехи + 1, β — неудачи + 1.', status: 'unseen' },
    { id: 'card-45', front: 'Что такое контекстуальные бандиты (Contextual Bandits)?', back: 'Алгоритмы, которые учитывают контекст (например, данные пользователя) при выборе варианта.', status: 'unseen' },
    { id: 'card-46', front: 'Что такое Softmax в контексте A/B-тестов?', back: 'Алгоритм, который назначает вероятность выбора варианта пропорционально его ожидаемой награде.', status: 'unseen' },
    { id: 'card-47', front: 'Как сравнить UCB1 и Thompson Sampling?', back: 'UCB1 детерминирован, имеет теоретические гарантии; Thompson Sampling байесовский, часто лучше на практике.', status: 'unseen' },
    { id: 'card-48', front: 'Что такое таблица сопряженности 2x2?', back: 'Таблица, которая показывает распределение успехов и неудач для двух групп в A/B-тесте.', status: 'unseen' },
    { id: 'card-49', front: 'Как избежать ошибок в A/B-тестах?', back: 'Проверять корректность разделения трафика, учитывать внешние факторы, избегать подглядывания.', status: 'unseen' },
    { id: 'card-50', front: 'Что такое сегментация результатов?', back: 'Анализ результатов для разных подгрупп пользователей (например, по устройству или географии).', status: 'unseen' },
    { id: 'card-51', front: 'Как документировать A/B-тесты?', back: 'Фиксировать гипотезы, параметры теста, результаты, выводы и принятые решения.', status: 'unseen' },
    { id: 'card-52', front: 'Что такое A/B/n-тестирование?', back: 'Тестирование более двух вариантов одновременно.', status: 'unseen' },
    { id: 'card-53', front: 'Какие внешние факторы могут повлиять на A/B-тест?', back: 'Праздники, сезонность, маркетинговые кампании, изменения в продукте.', status: 'unseen' },
    { id: 'card-54', front: 'Как интерпретировать отрицательные результаты A/B-теста?', back: 'Как ценные данные, которые помогают избежать неэффективных изменений.', status: 'unseen' },
    { id: 'card-55', front: 'Какие этические аспекты есть в A/B-тестировании?', back: 'Не вводить пользователей в заблуждение, минимизировать негативное влияние на их опыт.', status: 'unseen' },
    { id: 'card-56', front: 'Как выбрать уровень значимости (α) для теста?', back: 'Обычно используют α = 0.05, но можно выбрать другое значение в зависимости от контекста.', status: 'unseen' },
    { id: 'card-57', front: 'Что такое ложноположительная ошибка (Type I error)?', back: 'Ошибочное отклонение нулевой гипотезы, когда она верна (ложное обнаружение эффекта).', status: 'unseen' },
    { id: 'card-58', front: 'Что такое ложноотрицательная ошибка (Type II error)?', back: 'Неспособность отвергнуть нулевую гипотезу, когда она ложна (пропуск реального эффекта).', status: 'unseen' },
    { id: 'card-59', front: 'Как уменьшить вероятность Type I ошибки?', back: 'Использовать более строгий уровень значимости (например, α = 0.01).', status: 'unseen' },
    { id: 'card-60', front: 'Как увеличить мощность теста?', back: 'Увеличить размер выборки или допустимый MDE.', status: 'unseen' },
    { id: 'card-61', front: 'Что такое базовый уровень конверсии?', back: 'Текущее значение метрики в контрольной группе до начала теста.', status: 'unseen' },
    { id: 'card-62', front: 'Как рассчитать размер выборки для A/B-теста?', back: 'Использовать онлайн-калькуляторы или функции из statsmodels для расчета мощности.', status: 'unseen' },
    { id: 'card-63', front: 'Почему важно учитывать недельные циклы в тестах?', back: 'Поведение пользователей может различаться в будни и выходные.', status: 'unseen' },
    { id: 'card-64', front: 'Что такое многорукий бандит (Multi-Armed Bandit)?', back: 'Задача оптимизации, где нужно балансировать исследование и использование вариантов.', status: 'unseen' },
    { id: 'card-65', front: 'Как алгоритмы бандитов отличаются от классических A/B-тестов?', back: 'Они динамически распределяют трафик, уменьшая потери на неэффективных вариантах.', status: 'unseen' },
    { id: 'card-66', front: 'Что такое сожаление (regret) в задаче бандита?', back: 'Разница между наградой оптимального варианта и выбранного алгоритмом.', status: 'unseen' },
    { id: 'card-67', front: 'Как работает ε-decreasing greedy?', back: 'Аналогично ε-greedy, но ε постепенно уменьшается со временем.', status: 'unseen' },
    { id: 'card-68', front: 'Что такое параметр температуры в Softmax?', back: 'Параметр, который контролирует баланс между исследованием и эксплуатацией.', status: 'unseen' },
    { id: 'card-69', front: 'Как температура влияет на Softmax?', back: 'Высокая температура увеличивает исследование, низкая — эксплуатацию.', status: 'unseen' },
    { id: 'card-70', front: 'Что такое априорное распределение в байесовском подходе?', back: 'Наши предположения о параметрах до наблюдения данных.', status: 'unseen' },
    { id: 'card-71', front: 'Что такое апостериорное распределение в байесовском подходе?', back: 'Обновленные убеждения о параметрах после наблюдения данных.', status: 'unseen' },
    { id: 'card-72', front: 'Почему бета-распределение используют для бинарных данных?', back: 'Оно сопряжено с биномиальным распределением, что упрощает байесовское обновление.', status: 'unseen' },
    { id: 'card-73', front: 'Как обновлять бета-распределение в Thompson Sampling?', back: 'При успехе: α += 1; при неудаче: β += 1.', status: 'unseen' },
    { id: 'card-74', front: 'Что такое доверительные интервалы Хёффдинга?', back: 'Интервалы, которые гарантируют покрытие истинного значения с заданной вероятностью.', status: 'unseen' },
    { id: 'card-75', front: 'Как UCB1 связан с доверительными интервалами?', back: 'UCB1 использует верхнюю границу доверительного интервала для выбора действия.', status: 'unseen' },
    { id: 'card-76', front: 'Почему UCB1 считается алгоритмом обучения с подкреплением?', back: 'Он учится на взаимодействиях с окружением, балансирует исследование и использование.', status: 'unseen' },
    { id: 'card-77', front: 'Как реализовать UCB1 в Python?', back: 'Для каждого варианта считать среднюю награду и доверительный интервал, выбирать вариант с max UCB.', status: 'unseen' },
    { id: 'card-78', front: 'Как реализовать Thompson Sampling в Python?', back: 'Для каждого варианта генерировать случайное значение из бета-распределения, выбирать вариант с max значением.', status: 'unseen' },
    { id: 'card-79', front: 'Какие преимущества у байесовского подхода?', back: 'Учет априорных знаний, естественная оценка неопределенности, интерпретируемость.', status: 'unseen' },
    { id: 'card-80', front: 'Какие недостатки у байесовского подхода?', back: 'Вычислительная сложность, необходимость выбора априорных распределений.', status: 'unseen' },
    { id: 'card-81', front: 'Что такое отношение шансов (odds ratio)?', back: 'Отношение шансов успеха в тестовой группе к шансам в контрольной группе.', status: 'unseen' },
    { id: 'card-82', front: 'Как интерпретировать odds ratio?', back: 'OR > 1: тестовая группа лучше; OR < 1: контрольная группа лучше; OR = 1: нет разницы.', status: 'unseen' },
    { id: 'card-83', front: 'Что такое поправка Йейтса в хи-квадрате?', back: 'Поправка для увеличения точности хи-квадрат теста для малых выборок.', status: 'unseen' },
    { id: 'card-84', front: 'Когда использовать поправку Йейтса?', back: 'Для таблиц 2x2 с малыми ожидаемыми частотами (<5).', status: 'unseen' },
    { id: 'card-85', front: 'Что такое центральная предельная теорема (ЦПТ)?', back: 'Теорема, согласно которой выборочное среднее стремится к нормальному распределению при увеличении выборки.', status: 'unseen' },
    { id: 'card-86', front: 'Почему ЦПТ важна для A/B-тестов?', back: 'Она обосновывает использование Z-теста для пропорций при больших выборках.', status: 'unseen' },
    { id: 'card-87', front: 'Что такое нормальное распределение?', back: 'Симметричное распределение, задаваемое средним и стандартным отклонением.', status: 'unseen' },
    { id: 'card-88', front: 'Как проверить нормальность данных?', back: 'Использовать тесты Шапиро-Уилка или Колмогорова-Смирнова, построить Q-Q plot.', status: 'unseen' },
    { id: 'card-89', front: 'Что делать, если данные не нормальны?', back: 'Использовать непараметрические тесты (например, Манна-Уитни).', status: 'unseen' },
    { id: 'card-90', front: 'Что такое гомогенность дисперсий?', back: 'Равенство дисперсий в сравниваемых группах.', status: 'unseen' },
    { id: 'card-91', front: 'Как проверить гомогенность дисперсий?', back: 'Использовать тест Левена или Бартлетта.', status: 'unseen' },
    { id: 'card-92', front: 'Что делать, если дисперсии не равны?', back: 'Использовать модификации t-теста (например, Уэлча).', status: 'unseen' },
    { id: 'card-93', front: 'Что такое ANOVA?', back: 'Метод сравнения средних значений в трех и более группах.', status: 'unseen' },
    { id: 'card-94', front: 'Когда использовать ANOVA?', back: 'Для сравнения нескольких вариантов в A/B/n-тестах.', status: 'unseen' },
    { id: 'card-95', front: 'Что такое множественные сравнения?', back: 'Проблема увеличения вероятности ложноположительных результатов при множественных тестах.', status: 'unseen' },
    { id: 'card-96', front: 'Как корректировать множественные сравнения?', back: 'Использовать поправку Бонферрони или метод Холма.', status: 'unseen' },
    { id: 'card-97', front: 'Что такое ковариаты в A/B-тестах?', back: 'Дополнительные переменные, которые могут влиять на результат.', status: 'unseen' },
    { id: 'card-98', front: 'Как учесть ковариаты в анализе?', back: 'Использовать регрессионные модели (например, логистическую регрессию).', status: 'unseen' },
    { id: 'card-99', front: 'Что такое стратификация в A/B-тестах?', back: 'Разделение пользователей на подгруппы для более точного сравнения.', status: 'unseen' },
    { id: 'card-100', front: 'Как стратификация помогает в тестах?', back: 'Уменьшает вариабельность внутри групп, увеличивает мощность теста.', status: 'unseen' },
    { id: 'card-101', front: 'Что такое последовательный анализ?', back: 'Метод, позволяющий проверять результаты теста по мере поступления данных.', status: 'unseen' },
    { id: 'card-102', front: 'Какие методы последовательного анализа существуют?', back: 'Последовательный тест отношения правдоподобий, метод О\'Брайена-Флеминга.', status: 'unseen' },
    { id: 'card-103', front: 'Что такое бутстрап в статистике?', back: 'Метод оценки распределения статистики путем повторной выборки с заменой.', status: 'unseen' },
    { id: 'card-104', front: 'Как использовать бутстрап в A/B-тестах?', back: 'Для оценки доверительных интервалов разницы метрик без предположений о распределении.', status: 'unseen' },
    { id: 'card-105', front: 'Что такое байесовский фактор?', back: 'Мера относительной поддержки одной гипотезы по сравнению с другой в байесовском анализе.', status: 'unseen' },
    { id: 'card-106', front: 'Как интерпретировать байесовский фактор?', back: 'BF > 1 поддерживает H1, BF < 1 поддерживает H0; чем дальше от 1, тем сильнее поддержка.', status: 'unseen' },
    { id: 'card-107', front: 'Что такое ROC-кривая?', back: 'График, показывающий компромисс между чувствительностью и специфичностью модели.', status: 'unseen' },
    { id: 'card-108', front: 'Как ROC-кривая связана с A/B-тестами?', back: 'Может использоваться для оценки качества классификации вариантов.', status: 'unseen' },
    { id: 'card-109', front: 'Что такое AUC?', back: 'Площадь под ROC-кривой, мера качества классификатора.', status: 'unseen' },
    { id: 'card-110', front: 'Как AUC используется в A/B-тестах?', back: 'Для сравнения эффективности разных вариантов в задачах классификации.', status: 'unseen' },
    { id: 'card-111', front: 'Что такое F-мера?', back: 'Гармоническое среднее точности и полноты, мера качества классификации.', status: 'unseen' },
    { id: 'card-112', front: 'Как F-мера используется в A/B-тестах?', back: 'Для сравнения вариантов в задачах с дисбалансом классов.', status: 'unseen' },
    { id: 'card-113', front: 'Что такое чувствительность (recall)?', back: 'Доля истинных положительных случаев, которые правильно идентифицированы.', status: 'unseen' },
    { id: 'card-114', front: 'Что такое специфичность?', back: 'Доля истинных отрицательных случаев, которые правильно идентифицированы.', status: 'unseen' },
    { id: 'card-115', front: 'Что такое точность (precision)?', back: 'Доля правильно идентифицированных положительных случаев среди всех предсказанных положительных.', status: 'unseen' },
    { id: 'card-116', front: 'Как выбирать между точностью и полнотой?', back: 'Зависит от задачи: для минимизации ложных срабатываний — точность, для максимизации обнаружения — полнота.', status: 'unseen' },
    { id: 'card-117', front: 'Что такое матрица ошибок?', back: 'Таблица, показывающая количество истинных и ложных положительных/отрицательных предсказаний.', status: 'unseen' },
    { id: 'card-118', front: 'Как матрица ошибок используется в A/B-тестах?', back: 'Для визуализации эффективности разных вариантов в задачах классификации.', status: 'unseen' },
    { id: 'card-119', front: 'Что такое дисперсия?', back: 'Мера разброса данных вокруг среднего значения.', status: 'unseen' },
    { id: 'card-120', front: 'Как дисперсия влияет на A/B-тесты?', back: 'Высокая дисперсия требует большего размера выборки для обнаружения эффекта.', status: 'unseen' },
    { id: 'card-121', front: 'Что такое стандартное отклонение?', back: 'Квадратный корень из дисперсии, мера разброса в исходных единицах.', status: 'unseen' },
    { id: 'card-122', front: 'Как стандартное отклонение используется в A/B-тестах?', back: 'Для расчета доверительных интервалов и стандартных ошибок.', status: 'unseen' },
    { id: 'card-123', front: 'Что такое стандартная ошибка?', back: 'Стандартное отклонение выборочного распределения статистики.', status: 'unseen' },
    { id: 'card-124', front: 'Как стандартная ошибка используется в A/B-тестах?', back: 'Для оценки точности оценки среднего и расчета доверительных интервалов.', status: 'unseen' },
    { id: 'card-125', front: 'Что такое корреляция?', back: 'Мера линейной зависимости между двумя переменными.', status: 'unseen' },
    { id: 'card-126', front: 'Как корреляция влияет на A/B-тесты?', back: 'Высокая корреляция между метриками может требовать многомерного анализа.', status: 'unseen' },
    { id: 'card-127', front: 'Что такое ковариация?', back: 'Мера совместной изменчивости двух переменных.', status: 'unseen' },
    { id: 'card-128', front: 'Как ковариация используется в A/B-тестах?', back: 'Для анализа взаимосвязи между метриками и ковариатами.', status: 'unseen' },
    { id: 'card-129', front: 'Что такое линейная регрессия?', back: 'Модель, предсказывающая зависимую переменную как линейную комбинацию независимых.', status: 'unseen' },
    { id: 'card-130', front: 'Как линейная регрессия используется в A/B-тестах?', back: 'Для учета ковариат и стратификации при анализе результатов.', status: 'unseen' },
    { id: 'card-131', front: 'Что такое логистическая регрессия?', back: 'Модель для предсказания вероятности бинарного исхода.', status: 'unseen' },
    { id: 'card-132', front: 'Как логистическая регрессия используется в A/B-тестах?', back: 'Для анализа бинарных метрик (например, конверсии) с учетом ковариат.', status: 'unseen' },
    { id: 'card-133', front: 'Что такое случайный лес?', back: 'Ансамблевый метод, строящий множество деревьев решений.', status: 'unseen' },
    { id: 'card-134', front: 'Как случайный лес используется в A/B-тестах?', back: 'Для анализа нелинейных эффектов и взаимодействий между переменными.', status: 'unseen' },
    { id: 'card-135', front: 'Что такое градиентный бустинг?', back: 'Ансамблевый метод, последовательно строящий модели для исправления ошибок предыдущих.', status: 'unseen' },
    { id: 'card-136', front: 'Как градиентный бустинг используется в A/B-тестах?', back: 'Для анализа сложных зависимостей в данных и предсказания эффектов.', status: 'unseen' },
    { id: 'card-137', front: 'Что такое кластеризация?', back: 'Метод группировки схожих объектов без предварительных меток.', status: 'unseen' },
    { id: 'card-138', front: 'Как кластеризация используется в A/B-тестах?', back: 'Для сегментации пользователей перед тестированием или анализа результатов.', status: 'unseen' },
    { id: 'card-139', front: 'Что такое метод главных компонент (PCA)?', back: 'Метод снижения размерности путем проецирования данных на ортогональные оси.', status: 'unseen' },
    { id: 'card-140', front: 'Как PCA используется в A/B-тестах?', back: 'Для визуализации многомерных данных или уменьшения количества переменных.', status: 'unseen' },
    { id: 'card-141', front: 'Что такое t-SNE?', back: 'Метод визуализации многомерных данных в двумерном или трехмерном пространстве.', status: 'unseen' },
    { id: 'card-142', front: 'Как t-SNE используется в A/B-тестах?', back: 'Для визуализации различий между группами пользователей или вариантами.', status: 'unseen' },
    { id: 'card-143', front: 'Что такое UMAP?', back: 'Метод снижения размерности, сохраняющий как локальную, так и глобальную структуру данных.', status: 'unseen' },
    { id: 'card-144', front: 'Как UMAP используется в A/B-тестах?', back: 'Аналогично t-SNE, но с лучшей производительностью на больших данных.', status: 'unseen' },
    { id: 'card-145', front: 'Что такое кросс-валидация?', back: 'Метод оценки моделей путем разделения данных на обучающую и тестовую выборки.', status: 'unseen' },
    { id: 'card-146', front: 'Как кросс-валидация используется в A/B-тестах?', back: 'Для проверки устойчивости моделей, предсказывающих эффект теста.', status: 'unseen' },
    { id: 'card-147', front: 'Что такое переобучение?', back: 'Когда модель слишком точно подстраивается под обучающие данные и плохо обобщается.', status: 'unseen' },
    { id: 'card-148', front: 'Как избежать переобучения в A/B-тестах?', back: 'Использовать кросс-валидацию, регуляризацию, уменьшать сложность моделей.', status: 'unseen' },
  { id: 'card-149', front: 'Что такое регуляризация?', back: 'Метод предотвращения переобучения путем добавления штрафа за сложность модели.', status: 'unseen' },
    { id: 'card-150', front: 'Как регуляризация используется в A/B-тестах?', back: 'В регрессионных моделях для анализа результатов с множеством ковариат.', status: 'unseen' },
    { id: 'card-151', front: 'Что такое L1-регуляризация (Lasso)?', back: 'Регуляризация, которая может обнулять коэффициенты, выполняя отбор признаков.', status: 'unseen' },
    { id: 'card-152', front: 'Как Lasso используется в A/B-тестах?', back: 'Для выбора наиболее важных ковариат при анализе результатов теста.', status: 'unseen' },
    { id: 'card-153', front: 'Что такое L2-регуляризация (Ridge)?', back: 'Регуляризация, уменьшающая коэффициенты, но не обнуляющая их.', status: 'unseen' },
    { id: 'card-154', front: 'Как Ridge используется в A/B-тестах?', back: 'Для стабилизации оценок в регрессионных моделях при мультиколлинеарности.', status: 'unseen' },
    { id: 'card-155', front: 'Что такое Elastic Net?', back: 'Комбинация L1 и L2 регуляризации.', status: 'unseen' },
    { id: 'card-156', front: 'Как Elastic Net используется в A/B-тестах?', back: 'Когда нужно сочетать отбор признаков и уменьшение коэффициентов.', status: 'unseen' },
    { id: 'card-157', front: 'Что такое мультиколлинеарность?', back: 'Высокая корреляция между независимыми переменными в модели.', status: 'unseen' },
    { id: 'card-158', front: 'Как мультиколлинеарность влияет на A/B-тесты?', back: 'Может сделать оценки коэффициентов нестабильными и трудными для интерпретации.', status: 'unseen' },
    { id: 'card-159', front: 'Что такое гетероскедастичность?', back: 'Непостоянство дисперсии ошибок модели.', status: 'unseen' },
    { id: 'card-160', front: 'Как гетероскедастичность влияет на A/B-тесты?', back: 'Может привести к неэффективным оценкам и некорректным доверительным интервалам.', status: 'unseen' },
    { id: 'card-161', front: 'Что такое гомоскедастичность?', back: 'Постоянство дисперсии ошибок модели.', status: 'unseen' },
    { id: 'card-162', front: 'Почему гомоскедастичность важна в A/B-тестах?', back: 'Обеспечивает эффективность оценок и корректность статистических тестов.', status: 'unseen' },
    { id: 'card-163', front: 'Что такое остатки в регрессии?', back: 'Разница между наблюдаемыми и предсказанными значениями.', status: 'unseen' },
    { id: 'card-164', front: 'Как анализировать остатки в A/B-тестах?', back: 'Для проверки допущений модели (нормальность, гомоскедастичность).', status: 'unseen' },
    { id: 'card-165', front: 'Что такое Q-Q plot?', back: 'График для проверки нормальности распределения.', status: 'unseen' },
    { id: 'card-166', front: 'Как Q-Q plot используется в A/B-тестах?', back: 'Для проверки нормальности остатков регрессионных моделей.', status: 'unseen' },
    { id: 'card-167', front: 'Что такое критерий согласия?', back: 'Тест для проверки соответствия данных определенному распределению.', status: 'unseen' },
    { id: 'card-168', front: 'Как критерии согласия используются в A/B-тестах?', back: 'Для проверки нормальности данных перед применением параметрических тестов.', status: 'unseen' },
    { id: 'card-169', front: 'Что такое критерий Шапиро-Уилка?', back: 'Тест для проверки нормальности распределения.', status: 'unseen' },
    { id: 'card-170', front: 'Как критерий Шапиро-Уилка используется в A/B-тестах?', back: 'Для проверки нормальности данных перед t-тестом или ANOVA.', status: 'unseen' },
    { id: 'card-171', front: 'Что такое критерий Колмогорова-Смирнова?', back: 'Тест для сравнения распределений или проверки соответствия теоретическому распределению.', status: 'unseen' },
    { id: 'card-172', front: 'Как критерий Колмогорова-Смирнова используется в A/B-тестах?', back: 'Для сравнения распределений метрик между группами.', status: 'unseen' },
    { id: 'card-173', front: 'Что такое критерий Левена?', back: 'Тест для проверки равенства дисперсий в группах.', status: 'unseen' },
    { id: 'card-174', front: 'Как критерий Левена используется в A/B-тестах?', back: 'Для проверки гомогенности дисперсий перед t-тестом или ANOVA.', status: 'unseen' },
    { id: 'card-175', front: 'Что такое критерий Бартлетта?', back: 'Тест для проверки равенства дисперсий, чувствительный к отклонениям от нормальности.', status: 'unseen' },
    { id: 'card-176', front: 'Как критерий Бартлетта используется в A/B-тестах?', back: 'Альтернатива критерию Левена при нормальных данных.', status: 'unseen' },
    { id: 'card-177', front: 'Что такое критерий Фридмана?', back: 'Непараметрический тест для сравнения трех и более связанных групп.', status: 'unseen' },
    { id: 'card-178', front: 'Как критерий Фридмана используется в A/B-тестах?', back: 'Для сравнения нескольких вариантов при ненормальных данных.', status: 'unseen' },
    { id: 'card-179', front: 'Что такое критерий Крускала-Уоллиса?', back: 'Непараметрический аналог ANOVA для независимых групп.', status: 'unseen' },
    { id: 'card-180', front: 'Как критерий Крускала-Уоллиса используется в A/B-тестах?', back: 'Для сравнения нескольких вариантов при ненормальных данных.', status: 'unseen' },
    { id: 'card-181', front: 'Что такое критерий знаков?', back: 'Непараметрический тест для сравнения двух связанных выборок.', status: 'unseen' },
    { id: 'card-182', front: 'Как критерий знаков используется в A/B-тестах?', back: 'Для анализа парных данных при ненормальных распределениях.', status: 'unseen' },
    { id: 'card-183', front: 'Что такое критерий Уилкоксона?', back: 'Непараметрический тест для сравнения двух связанных выборок (аналог парного t-теста).', status: 'unseen' },
    { id: 'card-184', front: 'Как критерий Уилкоксона используется в A/B-тестах?', back: 'Для анализа парных данных при ненормальных распределениях.', status: 'unseen' },
    { id: 'card-185', front: 'Что такое коэффициент корреляции Пирсона?', back: 'Мера линейной зависимости между двумя переменными.', status: 'unseen' },
    { id: 'card-186', front: 'Как коэффициент Пирсона используется в A/B-тестах?', back: 'Для анализа связи между метриками и ковариатами.', status: 'unseen' },
    { id: 'card-187', front: 'Что такое коэффициент корреляции Спирмена?', back: 'Мера монотонной зависимости между двумя переменными.', status: 'unseen' },
    { id: 'card-188', front: 'Как коэффициент Спирмена используется в A/B-тестах?', back: 'Для анализа нелинейных зависимостей между метриками.', status: 'unseen' },
    { id: 'card-189', front: 'Что такое коэффициент корреляции Кендалла?', back: 'Мера ранговой корреляции, устойчивая к выбросам.', status: 'unseen' },
    { id: 'card-190', front: 'Как коэффициент Кендалла используется в A/B-тестах?', back: 'Для анализа зависимостей при небольших выборках с выбросами.', status: 'unseen' },
    { id: 'card-191', front: 'Что такое коэффициент детерминации R²?', back: 'Доля дисперсии зависимой переменной, объясненная моделью.', status: 'unseen' },
    { id: 'card-192', front: 'Как R² используется в A/B-тестах?', back: 'Для оценки качества регрессионных моделей при анализе результатов.', status: 'unseen' },
    { id: 'card-193', front: 'Что такое скорректированный R²?', back: 'R² с поправкой на количество предикторов в модели.', status: 'unseen' },
    { id: 'card-194', front: 'Как скорректированный R² используется в A/B-тестах?', back: 'Для сравнения моделей с разным количеством предикторов.', status: 'unseen' },
    { id: 'card-195', front: 'Что такое AIC (информационный критерий Акаике)?', back: 'Мера качества модели с учетом её сложности.', status: 'unseen' },
    { id: 'card-196', front: 'Как AIC используется в A/B-тестах?', back: 'Для выбора лучшей модели при анализе результатов теста.', status: 'unseen' },
    { id: 'card-197', front: 'Что такое BIC (байесовский информационный критерий)?', back: 'Аналогичен AIC, но с более строгим штрафом за сложность модели.', status: 'unseen' },
    { id: 'card-198', front: 'Как BIC используется в A/B-тестах?', back: 'Для выбора лучшей модели, особенно при больших выборках.', status: 'unseen' },
    { id: 'card-199', front: 'Что такое кросс-энтропия?', back: 'Мера расхождения между распределениями, часто используемая в классификации.', status: 'unseen' },
    { id: 'card-200', front: 'Как кросс-энтропия используется в A/B-тестах?', back: 'Для оценки качества моделей классификации при анализе бинарных метрик.', status: 'unseen' }
]


            let currentCardIndex = 0;
            let shuffledOrder = [];
            let isShuffled = false;

             let currentDeck = []; // Карточки, которые сейчас отображаются
             let isReviewMode = false;

            let timerInterval = null;
            let secondsElapsed = 0;


            // --- Timer Functions ---
             function formatTime(seconds) {
                 const h = Math.floor(seconds / 3600);
                 const m = Math.floor((seconds % 3600) / 60);
                 const s = seconds % 60;
                 const padded = [m, s].map(val => val.toString().padStart(2, '0'));
                 if (h > 0) {
                     return `${h.toString().padStart(2, '0')}:${padded[0]}:${padded[1]}`;
                 }
                 return `${padded[0]}:${padded[1]}`;
             }

             function startTimer() {
                 if (timerInterval) clearInterval(timerInterval);
                 timerDisplay.textContent = formatTime(secondsElapsed);
                 timerInterval = setInterval(() => {
                     secondsElapsed++;
                     timerDisplay.textContent = formatTime(secondsElapsed);
                 }, 1000);
             }

             function stopTimer() {
                 if (timerInterval) {
                     clearInterval(timerInterval);
                     timerInterval = null;
                 }
             }

             function resetTimer() {
                 stopTimer();
                 secondsElapsed = 0;
                 timerDisplay.textContent = formatTime(secondsElapsed);
             }


            // --- Card Display and Navigation ---

            function getCardData(index) {
                 const sourceCards = (isShuffled && !isReviewMode && shuffledOrder && shuffledOrder.length === cards.length) ?
                                    shuffledOrder.map(i => cards[i]) :
                                    currentDeck;

                 if (sourceCards.length === 0) {
                     return null;
                 }

                 const actualIndex = index % sourceCards.length;
                 const wrappedIndex = actualIndex < 0 ? actualIndex + sourceCards.length : actualIndex;

                 if (isShuffled && !isReviewMode && shuffledOrder && shuffledOrder.length === cards.length) {
                      const originalIndex = shuffledOrder[wrappedIndex];
                      return cards[originalIndex];
                  } else {
                      return currentDeck[wrappedIndex];
                  }
            }

            function displayCard(index) {
                 // Проверяем, есть ли карточки в текущей колоде
                if (currentDeck.length === 0) {
                     cardFrontText.textContent = isReviewMode ? "Нет карточек для повторения." : "Нет карточек.";
                     cardBackText.textContent = isReviewMode ? "Добавьте карточки или отметьте их для повторения." : "Добавьте карточки.";
                     flashcard.classList.remove('is-flipped');
                     prevButton.disabled = true;
                     nextButton.disabled = true;
                     actionButtons.forEach(btn => btn.style.visibility = 'hidden');
                     shuffleButton.disabled = true;
                     toggleReviewModeButton.disabled = true;
                     currentCardIndex = 0;
                     updateStats();
                     return;
                }

                // Включаем кнопки, если они были отключены
                 prevButton.disabled = false;
                 nextButton.disabled = false;
                 actionButtons.forEach(btn => btn.style.visibility = 'visible');
                 shuffleButton.disabled = isReviewMode;
                 toggleReviewModeButton.disabled = false;


                // Корректируем индекс, чтобы он оставался в пределах текущей колоды (циклическая навигация)
                currentCardIndex = index;
                if (currentCardIndex < 0) currentCardIndex = currentDeck.length - 1;
                if (currentCardIndex >= currentDeck.length) currentCardIndex = 0;


                const card = getCardData(currentCardIndex);


                if (card) {
                    cardFrontText.textContent = card.front;
                    cardBackText.textContent = card.back;
                } else {
                     console.error("[displayCard] getCardData returned null.");
                     cardFrontText.textContent = "Ошибка загрузки карточки";
                     cardBackText.textContent = "Ошибка загрузки карточки";
                }

                flashcard.classList.remove('is-flipped'); // <<< Убедимся, что всегда показываем лицевую сторону следующей карточки

                updateStats();
            }

            function flipCard() {
                 if (currentDeck.length === 0) return;
                flashcard.classList.toggle('is-flipped');
            }

            function nextCard() {
                if (currentDeck.length === 0) {
                     return;
                }
                 const nextIndex = (currentCardIndex + 1) % currentDeck.length;
                displayCard(nextIndex);
            }

            function prevCard() {
                 if (currentDeck.length === 0) {
                      return;
                 }
                 const prevIndex = (currentCardIndex - 1 + currentDeck.length) % currentDeck.length;
                displayCard(prevIndex);
            }

            function shuffleCards() {
                if (cards.length === 0 || isReviewMode) {
                     return;
                }

                isReviewMode = false;
                shuffleButton.disabled = false;
                // Текст кнопки "Повторить" будет обновлен в updateStats

                shuffledOrder = Array.from({ length: cards.length }, (_, i) => i);

                 // Алгоритм перемешивания Фишера-Йетса
                for (let i = shuffledOrder.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledOrder[i], shuffledOrder[j]] = [shuffledOrder[j], shuffledOrder[i]]; // меняем местами
                }
                isShuffled = true;
                currentDeck = cards; // currentDeck все еще полная колода
                currentCardIndex = 0;
                displayCard(currentCardIndex); // Обновляем дисплей
            }

             // --- Режим повторения ---
             function toggleReviewMode() {
                 if (cards.length === 0) {
                     return;
                 }

                 stopTimer();

                 if (!isReviewMode) { // Переключаемся в режим повторения
                     const reviewCards = cards.filter(card => card.status === 'review');
                     if (reviewCards.length === 0) {
                         alert("Нет карточек, требующих повторения.");
                         startTimer(); // Возобновляем таймер
                         return;
                     }
                     isReviewMode = true;
                     currentDeck = reviewCards; // Теперь currentDeck только для повторения
                     shuffleButton.disabled = true;
                     toggleReviewModeButton.textContent = `Показать все (${cards.length})`; // Показываем общее кол-во при выходе
                     currentCardIndex = 0; // Начинаем сначала колоды повторения
                 } else { // Переключаемся обратно в обычный режим
                     isReviewMode = false;
                     currentDeck = cards; // Возвращаемся к полной колоде
                     isShuffled = false; // Сбрасываем перемешивание при выходе из режима повторения
                     shuffledOrder = Array.from({ length: cards.length }, (_, i) => i); // Возвращаем исходный порядок
                     shuffleButton.disabled = false;
                     const reviewCount = cards.filter(card => card.status === 'review').length;
                     toggleReviewModeButton.textContent = `Повторить (${reviewCount})`; // Обновляем счетчик
                      currentCardIndex = 0; // Начинаем сначала полной колоды
                 }

                 displayCard(currentCardIndex); // Отображаем первую карточку новой колоды
                 startTimer();
             }


            // --- Status ---
            function markCard(status) {
                 if (currentDeck.length === 0 || !flashcard.classList.contains('is-flipped')) {
                     return;
                 }

                const currentCardOnDisplay = getCardData(currentCardIndex);

                if (!currentCardOnDisplay) {
                     console.error("[markCard] Could not get card data for current index.");
                     return;
                }

                // Находим эту карточку в оригинальном массиве cards, чтобы обновить ее статус там
                const originalCard = cards.find(c => c.id === currentCardOnDisplay.id);

                if (originalCard) {
                    const oldStatus = originalCard.status;
                    originalCard.status = status; // Обновляем статус в оригинальном массиве


                     // Если мы в режиме повторения И статус изменился с 'review' на что-то другое,
                     // удаляем карточку из currentDeck
                     if (isReviewMode && oldStatus === 'review' && status !== 'review') {
                          currentDeck = currentDeck.filter(c => c.id !== originalCard.id);

                          // Корректируем currentCardIndex, если он стал невалидным после удаления
                           if (currentDeck.length === 0) {
                               currentCardIndex = 0; // Колода стала пустой
                           } else if (currentCardIndex >= currentDeck.length) {
                              currentCardIndex = currentDeck.length - 1; // Adjust index if it's now out of bounds
                           } else {
                               // Индекс остался валидным, остаемся на нем, displayCard покажет следующую по кругу
                           }

                     } else {
                         // Не в режиме повторения ИЛИ статус остался 'review'
                         // В этих случаях мы ДОЛЖНЫ перейти к следующей карточке в текущей колоде.
                         currentCardIndex = (currentCardIndex + 1) % currentDeck.length; // ИСПРАВЛЕНИЕ ПЕРЕХОДА!
                     }


                     updateStats(); // Обновляем статистику (основываясь на полном массиве cards)
                     checkCompletion(); // Проверяем, все ли изучено

                     // Переходим к следующей карточке в текущей (возможно, уменьшенной) колоде
                     // displayCard сам скорректирует индекс, если он вышел за пределы,
                     // и покажет лицевую сторону.
                     displayCard(currentCardIndex); // displayCard отобразит карточку по новому индексу и покажет лицевую сторону
                } else {
                     console.error("[markCard] Original card not found in 'cards' array.");
                }
            }

             // --- Statistics ---
             function updateStats() {
                 const total = cards.length;
                 const learnedCount = cards.filter(card => card.status === 'learned').length;
                 const reviewCount = cards.filter(card => card.status === 'review').length;
                 const unseenCount = cards.filter(card => card.status === 'unseen').length;
                 const seenCount = total - unseenCount;

                 // Обновляем сводную статистику в хедере
                 cardCountsDisplay.textContent = `И: ${learnedCount}, П: ${reviewCount}, В: ${total}`;


                 // Обновляем подробную статистику в блоке статистики
                 totalCardsStats.textContent = total;
                 learnedStats.textContent = learnedCount;
                 reviewStats.textContent = reviewCount;
                 seenStats.textContent = seenCount;

                 // Обновляем текст кнопки "Повторить" со актуальным числом карточек на повторении
                 // В режиме "Показать все" текст уже другой
                 if (!isReviewMode) {
                     toggleReviewModeButton.textContent = `Повторить (${reviewCount})`;
                 }
             }

             function toggleStatsVisibility() {
                  const isHidden = statsArea.style.display === 'none';
                  statsArea.style.display = isHidden ? 'block' : 'none';
                  toggleStatsButton.textContent = isHidden ? 'Скрыть статистику' : 'Показать статистику';
             }

             // --- Completion Logic ---
             function checkCompletion() {
                 const allLearned = cards.length > 0 && cards.every(card => card.status === 'learned');
                 if (allLearned) {
                     showCompletionMessage();
                 }
             }

             function showCompletionMessage() {
                 stopTimer();
                 finalTimeDisplay.textContent = formatTime(secondsElapsed);
                 completionModal.classList.add('visible');
                 document.body.style.overflow = 'hidden';
             }

             function hideCompletionMessage() {
                 completionModal.classList.remove('visible');
                 document.body.style.overflow = '';
             }

            // --- Reset Functionality ---
            function resetApp() {
                 // Сбрасываем статусы всех карточек на 'unseen'
                 // Создаем НОВЫЙ массив карточек с исходными статусами
                 cards = cards;

                 // Сбрасываем все связанные состояния
                 isReviewMode = false;
                 isShuffled = false;
                 currentDeck = cards; // Возвращаемся к полной колоде
                 shuffledOrder = Array.from({ length: cards.length }, (_, i) => i); // Сбрасываем порядок перемешивания
                 currentCardIndex = 0;
                 resetTimer(); // Сбрасываем и запускаем таймер заново

                 // Обновляем UI (текст кнопок, статистика)
                 updateStats(); // updateStats обновит текст кнопки "Повторить" и сводную статистику
                 shuffleButton.disabled = false; // Включаем кнопку перемешать
                 toggleReviewModeButton.disabled = false; // Включаем кнопку повторения


                 // Перемешиваем и отображаем первую карточку
                 shuffleCards(); // shuffleCards вызовет displayCard
            }

            // --- "Начать заново" после завершения ---
            function startOverFromCompletion() {
                 hideCompletionMessage(); // Скрываем модальное окно
                 resetApp(); // Вызываем основную функцию сброса
            }


            // --- Theme Toggle ---
            function toggleTheme() {
                document.body.classList.toggle('dark-mode');
            }

            // --- Event Listeners ---
            flashcard.addEventListener('click', flipCard);

            // Навигация по кругу в текущей колоде
            prevButton.addEventListener('click', prevCard);
            nextButton.addEventListener('click', nextCard);

            shuffleButton.addEventListener('click', shuffleCards); // Слушатель для кнопки внизу
            toggleReviewModeButton.addEventListener('click', toggleReviewMode); // Слушатель для кнопки внизу
            themeToggleButton.addEventListener('click', toggleTheme);
            toggleStatsButton.addEventListener('click', toggleStatsVisibility);
            resetAppButton.addEventListener('click', resetApp); // Слушатель для кнопки внизу


            actionButtons.forEach(button => {
                button.addEventListener('click', (event) => {
                     event.stopPropagation(); // Предотвращаем переворот карточки
                     markCard(button.dataset.status);
                });
            });

             // Слушатель для кнопки "Начать заново" в модальном окне
             startOverButton.addEventListener('click', startOverFromCompletion);

             // Закрытие модального окна при клике вне контента
             completionModal.addEventListener('click', (event) => {
                 if (event.target === completionModal) {
                     // При желании, можно добавить закрытие по клику вне:
                     // hideCompletionMessage();
                 }
             });


             // --- Keyboard Navigation ---
             document.addEventListener('keydown', (event) => {
                 // Если модальное окно видимо, обрабатываем только Enter/Space
                 if (completionModal.classList.contains('visible')) {
                     if (event.code === 'Enter' || event.code === 'Space') {
                         event.preventDefault();
                         startOverButton.click(); // Эмулируем клик по кнопке
                     }
                     return; // Игнорируем другие нажатия клавиш
                 }

                 // Навигация (стрелки влево/вправо)
                 if (event.code === 'ArrowLeft') {
                     event.preventDefault();
                     prevCard();
                 } else if (event.code === 'ArrowRight') {
                     event.preventDefault();
                     nextCard();
                 }
                 // Переворот (Пробел)
                 else if (event.code === 'Space') {
                     event.preventDefault(); // Предотвращаем прокрутку страницы
                     flipCard();
                 }
                  // Добавить обработку клавиш 1, 2 и т.д. для отметки статуса, если нужно
             });


            // --- Initialization ---
            // Инициализация состояний по умолчанию при загрузке страницы
            // Массив cards уже определен выше с начальными статусами
            cards = cards;
			
            currentDeck = cards; // По умолчанию показываем все
            shuffledOrder = Array.from({ length: cards.length }, (_, i) => i);
            isShuffled = false;
            isReviewMode = false;
            currentCardIndex = 0;
            secondsElapsed = 0; // Таймер с 0 при старте
            statsArea.style.display = 'none';
            toggleStatsButton.textContent = 'Показать статистику';
            shuffleButton.disabled = false; // Включена по умолчанию
            toggleReviewModeButton.disabled = false; // Включена по умолчанию


            displayCard(currentCardIndex); // Отображаем начальную карточку (она вызовет updateStats)
            startTimer(); // Запускаем таймер
            checkCompletion(); // Проверяем завершение (вероятно, не сработает при старте без сохранения)
        });
    </script>
</body>
</html>