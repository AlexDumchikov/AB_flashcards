<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flash Cards App</title>
    <style>
        :root {
            --background-color: #ffffff;
            --text-color: #333333;
            --card-background: #f9f9f9;
            --card-border: #dddddd;
            --button-background: #007bff;
            --button-text: #ffffff;
            --button-background-hover: #0056b3;
            --learned-button: #28a745;
            --learned-button-hover: #218838;
            --review-button: #dc3545;
            --review-button-hover: #c82333;
            --reset-button: #6c757d; /* Цвет для кнопки сброса */
            --reset-button-hover: #5a6268;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --overlay-background: rgba(0, 0, 0, 0.5);
            --modal-background: #ffffff;
            --modal-text: #333333;
             --search-button-background: #f0ad4e; /* Цвет для кнопки поиска */
             --search-button-hover: #ec971f;
        }

        body.dark-mode {
            --background-color: #1e1e1e;
            --text-color: #f0f0f0; /* Светлый текст */
            --card-background: #333333; /* Темный фон карточки */
            --card-border: #555555;
            --button-background: #0056b3;
            --button-text: #ffffff;
            --button-background-hover: #003f80;
            --learned-button: #218838;
            --learned-button-hover: #1e7e34;
            --review-button: #c82333;
            --review-button-hover: #bd2130;
            --reset-button: #5a6268;
            --reset-button-hover: #6c757d;
            --shadow-color: rgba(255, 255, 255, 0.1);
            --overlay-background: rgba(0, 0, 0, 0.7);
            --modal-background: #333333;
            --modal-text: #f0f0f0;
             --search-button-background: #f0ad4e; /* Цвет для кнопки поиска */
             --search-button-hover: #ec971f;
        }

        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px; /* Общий отступ по краям */
            background-color: var(--background-color);
            color: var(--text-color); /* Наследуется для всего текста по умолчанию */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 10vh; /* Изменено на 10vh, чтобы контент не занимал весь экран */
            transition: background-color 0.3s ease, color 0.3s ease;
            box-sizing: border-box; /* Учитываем padding в общей ширине */
            overflow-y: auto; /* Позволяет прокручивать страницу, если контент не помещается */
        }

        header {
            text-align: center;
            margin-top: 5px; /* Расстояние от верхнего края экрана (от inner padding body) */
            margin-bottom: 5px; /* Расстояние до плашки */
            width: 100%;
            max-width: 600px;
            display: flex; /* Используем Flexbox */
            flex-direction: row; /* Элементы в строку по умолчанию */
            flex-wrap: wrap; /* Разрешаем перенос строки на маленьких экранах */
            align-items: center; /* Выравнивание по центру по вертикали */
            justify-content: center; /* Центрируем группу элементов в строке */
            gap: 10px; /* Промежуток в 10px между прямыми потомками header (h1 и .header-stats-timer) по горизонтали */
            /* gap применяется ко всем промежуткам, включая вертикальные при wrap */
            padding: 0 10px; /* Отступ по бокам */
            box-sizing: border-box;
        }


        header h1 {
            color: var(--text-color);
            margin: 0; /* Убираем margin */
            font-size: 12px; /* Размер шрифта заголовка 12px */
            flex-grow: 0; /* Заголовок не занимает все доступное пространство */
            flex-shrink: 1; /* Позволяем ему сжиматься */
            text-align: center; /* Центрируем текст заголовка */
            min-width: 100px; /* Минимальная ширина */
        }

         /* Группа статистики и таймера */
         .header-stats-timer {
             display: flex;
             align-items: center;
             gap: 10px; /* Промежуток между статсами и таймером */
             flex-wrap: nowrap; /* Предотвращаем перенос внутри группы */
             flex-shrink: 0; /* Не сжимаем группу сильно */
             min-width: auto; /* Ширина определяется содержимым */

         }

         #card-counts {
             font-size: 1rem; /* Размер шрифта статистики */
             color: var(--text-color);
             white-space: nowrap; /* Предотвращаем перенос текста статистики */
             flex-shrink: 1; /* Разрешаем сжиматься */
             min-width: 0; /* Позволяем сжиматься меньше содержимого */
             text-overflow: ellipsis; /* Добавляем многоточие */
             overflow: hidden; /* Скрываем вылезающий текст */
         }

        #timer {
             font-size: 1rem; /* Размер шрифта таймера */
             font-weight: bold;
             color: var(--text-color);
             white-space: nowrap; /* Предотвращаем перенос текста таймера */
             flex-shrink: 0; /* Не сжимаем таймер сильно */
             min-width: auto; /* Ширина определяется содержимым */
         }

         /* Стили для кнопок в хедере (их нет в этой версии) */


        main {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-grow: 1; /* Занимает доступное пространство */
            justify-content: center; /* Центрируем контент по вертикали */
            padding-bottom: 80px; /* Отступ снизу для кнопок управления внизу */
        }

        .card-container {
            width: 100%;
            perspective: 1000px; /* Для 3D эффекта переворота */
            margin-bottom: 20px;
            max-width: 400px; /* Ограничение ширины карточки */
            height: 550px; /* Увеличена высота плашки на 30% от 350px */
            flex-shrink: 0; /* Не сжимается */
        }

        .flashcard {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1); /* Плавный переход */
            box-shadow: 0 4px 8px var(--shadow-color);
            border-radius: 10px;
            background-color: var(--card-background); /* Фон карточки */
            border: 1px solid var(--card-border);
            cursor: pointer; /* Показываем, что карточка кликабельна */
        }

        .flashcard.is-flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Скрываем обратную сторону */
            /* === Используем Flexbox для центрирования содержимого === */
            display: flex;
            flex-direction: column; /* Располагаем элементы вертикально */
            justify-content: center; /* Центрируем содержимое вертикально */
            align-items: center; /* Центрируем содержимое горизонтально */
            padding: 20px;
            text-align: center; /* Выравнивание текста по центру внутри блока */
            border-radius: 10px;
            overflow: hidden; /* Скрываем вылезающий контент */
            box-sizing: border-box; /* Учитываем padding в размере */
             color: var(--text-color); /* Явно указываем цвет текста карточки */
        }

        .card-front {
            z-index: 2;
            transform: rotateY(0deg);
        }

        .card-back {
            transform: rotateY(180deg);
            justify-content: space-between; /* Разносим текст и кнопки */
            padding-bottom: 80px; /* Отступ для кнопок внизу */
            /* box-sizing: border-box; already set in .card-face */
        }

        .card-text {
            font-size: 1.5rem; /* Крупный шрифт */
            margin: 0; /* Убираем стандартные margin */
            overflow-y: auto; /* Добавляем прокрутку, если текст длинный */
            word-break: break-word; /* Перенос длинных слов */
            padding: 10px 0; /* Небольшой вертикальный отступ */
            width: 100%; /* Занимает всю доступную ширину */
             flex-grow: 1; /* Позволяет тексту занимать доступное пространство */
             /* color: var(--text-color); Inherited from .card-face */
        }
         .card-back .card-text {
             margin-bottom: 20px; /* Отступ между текстом и кнопками на обратной стороне */
              flex-grow: 0; /* Текст не должен занимать все место, чтобы оставить место кнопкам */
              max-height: calc(100% - 60px); /* Грубая оценка высоты, чтобы кнопки поместились */
         }


        .card-actions {
            position: absolute; /* Позиционируем абсолютно */
            bottom: 20px; /* Прижимаем к низу */
            left: 0;
            right: 0;
            display: flex;
			height: 50px;
            justify-content: center;
            gap: 50px; /* Промежуток между кнопками */
            padding: 0 20px;
            box-sizing: border-box;
            flex-shrink: 0;
            flex-wrap: nowrap; /* <<< Главное: предотвращаем перенос кнопок действий */
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            transition: background-color 0.2s ease;
            background-color: var(--button-background);
            color: var(--button-text); /* Цвет текста на кнопках */
        }

        button:hover {
            background-color: var(--button-background-hover);
        }

        .action-button {
             flex-grow: 1; /* Кнопки действий занимают равное пространство */
             max-width: 112.5px; /* <<< Уменьшена максимальная ширина на 25% (150 * 0.75) */
             flex-shrink: 0; /* <<< Не сжимаются меньше минимального размера */
             min-width: 60px; /* <<< Задаем минимальную ширину, чтобы текст был читаемым */
             box-sizing: border-box; /* Учитываем padding в ширине */
             /* Убраны flex-basis: auto и max-width: none из @media - они не нужны при nowrap */
        }

        .action-button.learned {
            background-color: var(--learned-button);
        }
        .action-button.learned:hover {
            background-color: var(--learned-button-hover);
        }

        .action-button.review {
            background-color: var(--review-button);
        }
        .action-button.review:hover {
            background-color: var(--review-button-hover);
        }

        /* Style for the new search button */
        #search-button {
            margin-top: 10px; /* Отступ сверху */
            background-color: #9400d3;
            color: var(--button-text);
            width: 100%; /* Кнопка занимает всю доступную ширину */
            max-width: 400px; /* Ограничиваем ширину по ширине карточки */
            box-sizing: border-box;
        }

        #search-button:hover {
            background-color: #800080 ;
        }


        .navigation, .controls {
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap; /* Перенос кнопок на маленьких экранах */
        }

        .navigation button, .controls button {
             flex-basis: 150px; /* Минимальная ширина кнопок навигации/контроля */
             flex-grow: 1; /* Позволяем растягиваться */
             max-width: 200px; /* Максимальная ширина */
        }

         /* Стили для кнопок в controls, их стало 5 */
         .controls button {
             flex-basis: 100px; /* Скорректируем базовую ширину для 5 кнопок */
             flex-grow: 1;
             max-width: 150px; /* Скорректируем макс ширину */
             font-size: 0.9rem; /* Слегка уменьшим шрифт */
             padding: 8px 12px; /* Слегка уменьшим padding */
             white-space: nowrap; /* Предотвращаем перенос текста внутри кнопок */
         }

        #reset-app {
            background-color: var(--reset-button); /* Применяем цвет сброса к кнопке в controls */
        }
         #reset-app:hover {
            background-color: var(--reset-button-hover);
        }


        .stats-area {
            margin-top: 30px;
            padding: 20px;
            border: 1px solid var(--card-border);
            border-radius: 10px;
            background-color: var(--card-background); /* Фон статистики */
            width: 100%;
            max-width: 600px;
            text-align: center;
             color: var(--text-color); /* Цвет текста статистики */
        }

        /* Модальное окно завершения */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--overlay-background);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Поверх всего остального */
            visibility: hidden; /* Скрыто по умолчанию */
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.visible {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background: var(--modal-background);
            color: var(--modal-text); /* Цвет текста в модальном окне */
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 90%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }

        .modal-content h2 {
            margin-top: 0;
            color: var(--modal-text); /* Цвет заголовка в модальном окне */
        }

        .modal-content button {
            margin-top: 20px;
        }


        /* Responsive adjustments */
        @media (max-width: 600px) {
             /* Header позволяет перенос строки */
             header {
                 flex-direction: column; /* Элементы в колонку на маленьких экранах */
                 gap: 5px; /* Расстояние 5px между элементами при вертикальном стеке */
                 padding: 0 10px;
                 align-items: stretch; /* Растягиваем элементы */
             }

             header h1 {
                  font-size: 18px; /* Размер заголовка 12px на мобильном тоже */
                  text-align: center;
                  width: 100%; /* Занимает всю ширину */
                  min-width: auto; /* Сбрасываем минимальную ширину */
             }

             .header-stats-timer {
                 flex-wrap: wrap; /* Разрешаем перенос внутри группы */
                 justify-content: center; /* Центрируем группу, когда она сама перенесена */
                 width: 100%; /* Занимает всю ширину */
                 gap: 10px; /* Расстояние между статсами и таймером внутри группы */
             }

             #card-counts, #timer {
                 font-size: 0.9rem; /* Уменьшаем шрифт */
                 text-align: center;
                 flex-shrink: 1;
                 min-width: auto; /* Сбрасываем мин ширину */
                 width: auto; /* Ширина по содержимому */
             }

             /* Adjust main padding */
             main {
                 padding-top: 5px; /* Расстояние 5px после хедера на мобильном */
             }


            .card-container {
                 height: 550px; /* Увеличена высота плашки на 30% от 300px на мобильном */
                 max-width: 100%;
            }

            .card-text {
                font-size: 1.3rem;
            }

            button {
                padding: 8px 15px;
                font-size: 0.9rem;
            }

             /* Controls остаются с переносом */
             .navigation button, .controls button {
                 flex-basis: auto;
                 flex-grow: 1;
                 max-width: none;
             }

             .card-actions {
                 flex-direction: row; /* <<< Фиксируем в строку даже на мобильных */
                 flex-wrap: nowrap; /* <<< Отключаем перенос */
                 gap: 10px; /* Уменьшаем промежуток между кнопками действий */
                 bottom: 10px;
                 justify-content: center; /* Центрируем кнопки в строке */
                 padding: 0 10px; /* Adjust padding */
             }

             .action-button {
                  max-width: 112.5px; /* <<< Сохраняем уменьшенную макс ширину */
                  min-width: 60px; /* <<< Сохраняем мин ширину */
                  flex-grow: 1; /* Позволяем им делиться пространством */
                  flex-shrink: 0; /* Не сжимаются меньше мин ширины */
                  padding: 8px 10px; /* Уменьшаем padding */
                  font-size: 0.8rem; /* Уменьшаем шрифт */
             }


             .card-back {
                 padding-bottom: 110px;
             }

             #search-button {
                 max-width: 100%; /* На мобильных кнопка поиска занимает всю ширину */
             }

             .modal-content {
                 padding: 20px;
             }
        }


        /* Accessibility (basic keyboard focus indication) */
        button:focus-visible {
            outline: 2px solid var(--button-background-hover);
            outline-offset: 2px;
        }
         #reset-app:focus-visible {
            outline-color: var(--reset-button-hover);
         }
         #search-button:focus-visible {
             outline-color: var(--search-button-hover);
         }
         .modal-content button:focus-visible {
             outline-color: var(--button-background-hover); /* Или другой цвет для модальной кнопки */
         }
    </style>
</head>
<body class="dark-mode">
    <header>
        <h1>A/B TESTS</h1>
        <div class="header-stats-timer">
            <div id="card-counts">И: 0, П: 0, В: 0</div>
            <div id="timer">00:00</div>
        </div>
    </header>

    <main>
        <div class="card-container">
            <div class="flashcard" id="flashcard">
                <div class="card-face card-front">
                    <p class="card-text" id="card-front-text"></p>
                </div>
                <div class="card-face card-back">
                    <p class="card-text" id="card-back-text"></p>
                    <div class="card-actions">
                        <button class="action-button learned" data-status="learned">Изучено</button>
                        <button class="action-button review" data-status="review">Повторить</button>
                    </div>
                </div>
            </div>
        </div>

        <button id="search-button">Узнать детали</button>

        <div class="navigation">
            <button id="prev-card">&laquo; Назад</button>
            <button id="next-card">&raquo; Вперед</button>
        </div>

        <div class="controls">
            <button id="shuffle-cards">Перемешать</button>
            <button id="toggle-review-mode">Повторить (0)</button>
            <button id="toggle-stats">Показать статистику</button>
            <button id="theme-toggle">Сменить тему</button>
            <button id="reset-app">Сброс</button>
        </div>

        <div class="stats-area" id="stats-area">
            <h2>Статистика</h2>
            <p>Всего карточек: <span id="total-cards-stats">0</span></p>
            <p>Изучено: <span id="learned-stats">0</span></p>
            <p>Требуют повторения: <span id="review-stats">0</span></p>
            <p>Просмотрено: <span id="seen-stats">0</span></p>
        </div>
    </main>

    <div class="modal-overlay" id="completion-modal">
        <div class="modal-content">
            <h2>Поздравляем!</h2>
            <p>Вы изучили все карточки!</p>
            <p>Ваше время: <span id="final-time">00:00</span></p>
            <button id="start-over-button">Начать заново</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const flashcard = document.getElementById('flashcard');
            const cardFrontText = document.getElementById('card-front-text');
            const cardBackText = document.getElementById('card-back-text');
            const prevButton = document.getElementById('prev-card');
            const nextButton = document.getElementById('next-card');
            const shuffleButton = document.getElementById('shuffle-cards');
            const toggleReviewModeButton = document.getElementById('toggle-review-mode');
            const themeToggleButton = document.getElementById('theme-toggle');
            const actionButtons = document.querySelectorAll('.card-actions .action-button');
            const toggleStatsButton = document.getElementById('toggle-stats');
            const statsArea = document.getElementById('stats-area');
            const totalCardsStats = document.getElementById('total-cards-stats');
            const learnedStats = document.getElementById('learned-stats');
            const reviewStats = document.getElementById('review-stats');
            const seenStats = document.getElementById('seen-stats');
            const timerDisplay = document.getElementById('timer');
            const completionModal = document.getElementById('completion-modal');
            const startOverButton = document.getElementById('start-over-button');
            const finalTimeDisplay = document.getElementById('final-time');
            const resetAppButton = document.getElementById('reset-app');
            const cardCountsDisplay = document.getElementById('card-counts');
            const searchButton = document.getElementById('search-button'); // Get the new search button


            // --- Sample Data ---
            // Статусы сбрасываются при каждой загрузке, т.к. нет сохранения
            let cards = [
 { id: 'card-1', front: 'Что такое A/B-тестирование?', back: 'Метод сравнения двух версий чего-либо (например, веб-страницы) для определения, какая из них работает лучше.', status: 'unseen' },
    { id: 'card-2', front: 'Какие основные цели A/B-тестирования?', back: 'Улучшение ключевых показателей (конверсия, кликабельность, продажи), снижение рисков при внедрении изменений, принятие решений на основе данных.', status: 'unseen' },
    { id: 'card-3', front: 'Что такое контрольная группа в A/B-тесте?', back: 'Группа пользователей, которой показывают текущую (старую) версию.', status: 'unseen' },
    { id: 'card-4', front: 'Что такое тестовая группа в A/B-тесте?', back: 'Группа пользователей, которой показывают новую (экспериментальную) версию.', status: 'unseen' },
    { id: 'card-5', front: 'Что такое статистическая значимость?', back: 'Вероятность того, что разница в результатах между группами не случайна.', status: 'unseen' },
    { id: 'card-6', front: 'Какие типы данных используются в A/B-тестах?', back: 'Бинарные (успех/неудача) и непрерывные (числовые значения).', status: 'unseen' },
    { id: 'card-7', front: 'Какие тесты используют для бинарных данных?', back: 'Z-тест для пропорций, критерий хи-квадрат Пирсона, точный тест Фишера.', status: 'unseen' },
    { id: 'card-8', front: 'Какие тесты используют для непрерывных данных?', back: 't-тест Стьюдента (для нормального распределения), тест Манна-Уитни (для ненормального распределения).', status: 'unseen' },
    { id: 'card-9', front: 'Когда используют Z-тест для пропорций?', back: 'Для больших выборок, где количество успехов и неудач в каждой группе не менее 5-10.', status: 'unseen' },
    { id: 'card-10', front: 'Когда используют точный тест Фишера?', back: 'Для малых выборок, когда ожидаемые частоты в таблице сопряженности меньше 5.', status: 'unseen' },
    { id: 'card-11', front: 'Что такое p-value?', back: 'Вероятность получить наблюдаемую разницу (или более экстремальную) при условии, что нулевая гипотеза верна.', status: 'unseen' },
    { id: 'card-12', front: 'Как интерпретировать p-value?', back: 'Если p-value < 0.05, разница статистически значима; если p-value ≥ 0.05, разница незначима.', status: 'unseen' },
    { id: 'card-13', front: 'Что такое доверительный интервал?', back: 'Диапазон значений, в котором с определенной вероятностью находится истинное значение метрики.', status: 'unseen' },
    { id: 'card-14', front: 'Что такое минимальный детектируемый эффект (MDE)?', back: 'Наименьший размер эффекта, который мы хотим обнаружить с заданной мощностью теста.', status: 'unseen' },
    { id: 'card-15', front: 'Что такое мощность теста?', back: 'Вероятность правильно обнаружить статистически значимую разницу, если она существует.', status: 'unseen' },
    { id: 'card-16', front: 'Какие факторы влияют на размер выборки?', back: 'Базовая конверсия, MDE, уровень значимости (α), мощность теста (1-β).', status: 'unseen' },
    { id: 'card-17', front: 'Как избежать проблемы "подглядывания" (peeking)?', back: 'Не останавливать тест раньше времени, дождаться запланированного размера выборки.', status: 'unseen' },
    { id: 'card-18', front: 'Что такое эффект новизны?', back: 'Пользователи могут реагировать на изменения только потому, что они новые, а не потому, что они лучше.', status: 'unseen' },
    { id: 'card-19', front: 'Что такое A/A-тестирование?', back: 'Тест, где обе группы видят одинаковую версию, используется для проверки корректности системы.', status: 'unseen' },
    { id: 'card-20', front: 'Какие метрики часто используют в A/B-тестах?', back: 'Коэффициент конверсии, CTR, показатель отказов, время на странице, средний чек.', status: 'unseen' },
    { id: 'card-21', front: 'Как рассчитать коэффициент конверсии?', back: '(Количество конверсий / Общее количество посетителей) * 100%.', status: 'unseen' },
    { id: 'card-22', front: 'Как рассчитать CTR?', back: '(Количество кликов / Количество показов элемента) * 100%.', status: 'unseen' },
    { id: 'card-23', front: 'Как рассчитать показатель отказов?', back: '(Количество сеансов с одной страницей / Общее количество сеансов) * 100%.', status: 'unseen' },
    { id: 'card-24', front: 'Что такое нулевая гипотеза (H0)?', back: 'Гипотеза об отсутствии значимых различий между группами.', status: 'unseen' },
    { id: 'card-25', front: 'Что такое альтернативная гипотеза (H1)?', back: 'Гипотеза о наличии значимых различий между группами.', status: 'unseen' },
    { id: 'card-26', front: 'Как сформулировать гипотезу для A/B-теста?', back: 'Если мы изменим [элемент], то [метрика] изменится [определенным образом].', status: 'unseen' },
    { id: 'card-27', front: 'Почему важно тестировать одну переменную за раз?', back: 'Чтобы точно определить, какое изменение повлияло на результат.', status: 'unseen' },
    { id: 'card-28', front: 'Как выбрать целевую аудиторию для теста?', back: 'Определить сегмент пользователей (например, новые или вернувшиеся) или тестировать на всех.', status: 'unseen' },
    { id: 'card-29', front: 'Как рассчитать продолжительность теста?', back: 'Учитывать размер выборки, недельные циклы, сезонность и достижение необходимого трафика.', status: 'unseen' },
    { id: 'card-30', front: 'Почему важна рандомизация в A/B-тестах?', back: 'Чтобы минимизировать систематические ошибки и обеспечить репрезентативность выборок.', status: 'unseen' },
    { id: 'card-31', front: 'Какие Python-библиотеки используют для A/B-тестов?', back: 'scipy.stats, statsmodels, numpy, pandas.', status: 'unseen' },
    { id: 'card-32', front: 'Как провести Z-тест для пропорций в Python?', back: 'Использовать функцию proportions_ztest из statsmodels.stats.proportion.', status: 'unseen' },
    { id: 'card-33', front: 'Как провести t-тест в Python?', back: 'Использовать функцию ttest_ind из scipy.stats.', status: 'unseen' },
    { id: 'card-34', front: 'Как провести критерий хи-квадрат в Python?', back: 'Использовать функцию chi2_contingency из scipy.stats.', status: 'unseen' },
    { id: 'card-35', front: 'Как провести точный тест Фишера в Python?', back: 'Использовать функцию fisher_exact из scipy.stats.', status: 'unseen' },
    { id: 'card-36', front: 'Как смоделировать данные для A/B-теста в Python?', back: 'Использовать numpy.random.binomial для бинарных данных или numpy.random.normal для непрерывных.', status: 'unseen' },
    { id: 'card-37', front: 'Что такое байесовское A/B-тестирование?', back: 'Подход, который обновляет убеждения о эффективности вариантов на основе априорных знаний и данных.', status: 'unseen' },
    { id: 'card-38', front: 'Что такое дилемма исследования и использования (Explore-Exploit)?', back: 'Компромисс между исследованием новых вариантов и использованием лучшего известного варианта.', status: 'unseen' },
    { id: 'card-39', front: 'Что такое алгоритм ε-greedy?', back: 'Алгоритм, который с вероятностью 1-ε выбирает лучший вариант, а с вероятностью ε — случайный.', status: 'unseen' },
    { id: 'card-40', front: 'Что такое алгоритм UCB1?', back: 'Алгоритм, который выбирает вариант с наибольшей верхней границей доверительного интервала.', status: 'unseen' },
    { id: 'card-41', front: 'Как работает алгоритм UCB1?', back: 'UCB = средняя награда + c * √(ln(t) / n), где c — параметр, t — общее число итераций, n — число выборов варианта.', status: 'unseen' },
    { id: 'card-42', front: 'Что такое Thompson Sampling?', back: 'Байесовский алгоритм, который выбирает вариант на основе случайной выборки из распределения вероятностей.', status: 'unseen' },
    { id: 'card-43', front: 'Как работает Thompson Sampling?', back: 'Для каждого варианта генерируется случайное значение из его распределения, выбирается вариант с наибольшим значением.', status: 'unseen' },
    { id: 'card-44', front: 'Какое распределение используют в Thompson Sampling для бинарных данных?', back: 'Бета-распределение (Beta(α, β)), где α — успехи + 1, β — неудачи + 1.', status: 'unseen' },
    { id: 'card-45', front: 'Что такое контекстуальные бандиты (Contextual Bandits)?', back: 'Алгоритмы, которые учитывают контекст (например, данные пользователя) при выборе варианта.', status: 'unseen' },
    { id: 'card-46', front: 'Что такое Softmax в контексте A/B-тестов?', back: 'Алгоритм, который назначает вероятность выбора варианта пропорционально его ожидаемой награде.', status: 'unseen' },
    { id: 'card-47', front: 'Как сравнить UCB1 и Thompson Sampling?', back: 'UCB1 детерминирован, имеет теоретические гарантии; Thompson Sampling байесовский, часто лучше на практике.', status: 'unseen' },
    { id: 'card-48', front: 'Что такое таблица сопряженности 2x2?', back: 'Таблица, которая показывает распределение успехов и неудач для двух групп в A/B-тесте.', status: 'unseen' },
    { id: 'card-49', front: 'Как избежать ошибок в A/B-тестах?', back: 'Проверять корректность разделения трафика, учитывать внешние факторы, избегать подглядывания.', status: 'unseen' },
    { id: 'card-50', front: 'Что такое сегментация результатов?', back: 'Анализ результатов для разных подгрупп пользователей (например, по устройству или географии).', status: 'unseen' },
    { id: 'card-51', front: 'Как документировать A/B-тесты?', back: 'Фиксировать гипотезы, параметры теста, результаты, выводы и принятые решения.', status: 'unseen' },
    { id: 'card-52', front: 'Что такое A/B/n-тестирование?', back: 'Тестирование более двух вариантов одновременно.', status: 'unseen' },
    { id: 'card-53', front: 'Какие внешние факторы могут повлиять на A/B-тест?', back: 'Праздники, сезонность, маркетинговые кампании, изменения в продукте.', status: 'unseen' },
    { id: 'card-54', front: 'Как интерпретировать отрицательные результаты A/B-теста?', back: 'Как ценные данные, которые помогают избежать неэффективных изменений.', status: 'unseen' },
    { id: 'card-55', front: 'Какие этические аспекты есть в A/B-тестировании?', back: 'Не вводить пользователей в заблуждение, минимизировать негативное влияние на их опыт.', status: 'unseen' },
    { id: 'card-56', front: 'Как выбрать уровень значимости (α) для теста?', back: 'Обычно используют α = 0.05, но можно выбрать другое значение в зависимости от контекста.', status: 'unseen' },
    { id: 'card-57', front: 'Что такое ложноположительная ошибка (Type I error)?', back: 'Ошибочное отклонение нулевой гипотезы, когда она верна (ложное обнаружение эффекта).', status: 'unseen' },
    { id: 'card-58', front: 'Что такое ложноотрицательная ошибка (Type II error)?', back: 'Неспособность отвергнуть нулевую гипотезу, когда она ложна (пропуск реального эффекта).', status: 'unseen' },
    { id: 'card-59', front: 'Как уменьшить вероятность Type I ошибки?', back: 'Использовать более строгий уровень значимости (например, α = 0.01).', status: 'unseen' },
    { id: 'card-60', front: 'Как увеличить мощность теста?', back: 'Увеличить размер выборки или допустимый MDE.', status: 'unseen' },
    { id: 'card-61', front: 'Что такое базовый уровень конверсии?', back: 'Текущее значение метрики в контрольной группе до начала теста.', status: 'unseen' },
    { id: 'card-62', front: 'Как рассчитать размер выборки для A/B-теста?', back: 'Использовать онлайн-калькуляторы или функции из statsmodels для расчета мощности.', status: 'unseen' },
    { id: 'card-63', front: 'Почему важно учитывать недельные циклы в тестах?', back: 'Поведение пользователей может различаться в будни и выходные.', status: 'unseen' },
    { id: 'card-64', front: 'Что такое многорукий бандит (Multi-Armed Bandit)?', back: 'Задача оптимизации, где нужно балансировать исследование и использование вариантов.', status: 'unseen' },
    { id: 'card-65', front: 'Как алгоритмы бандитов отличаются от классических A/B-тестов?', back: 'Они динамически распределяют трафик, уменьшая потери на неэффективных вариантах.', status: 'unseen' },
    { id: 'card-66', front: 'Что такое сожаление (regret) в задаче бандита?', back: 'Разница между наградой оптимального варианта и выбранного алгоритмом.', status: 'unseen' },
    { id: 'card-67', front: 'Как работает ε-decreasing greedy?', back: 'Аналогично ε-greedy, но ε постепенно уменьшается со временем.', status: 'unseen' },
    { id: 'card-68', front: 'Что такое параметр температуры в Softmax?', back: 'Параметр, который контролирует баланс между исследованием и эксплуатацией.', status: 'unseen' },
    { id: 'card-69', front: 'Как температура влияет на Softmax?', back: 'Высокая температура увеличивает исследование, низкая — эксплуатацию.', status: 'unseen' },
    { id: 'card-70', front: 'Что такое априорное распределение в байесовском подходе?', back: 'Наши предположения о параметрах до наблюдения данных.', status: 'unseen' },
    { id: 'card-71', front: 'Что такое апостериорное распределение в байесовском подходе?', back: 'Обновленные убеждения о параметрах после наблюдения данных.', status: 'unseen' },
    { id: 'card-72', front: 'Почему бета-распределение используют для бинарных данных?', back: 'Оно сопряжено с биномиальным распределением, что упрощает байесовское обновление.', status: 'unseen' },
    { id: 'card-73', front: 'Как обновлять бета-распределение в Thompson Sampling?', back: 'При успехе: α += 1; при неудаче: β += 1.', status: 'unseen' },
    { id: 'card-74', front: 'Что такое доверительные интервалы Хёффдинга?', back: 'Интервалы, которые гарантируют покрытие истинного значения с заданной вероятностью.', status: 'unseen' },
    { id: 'card-75', front: 'Как UCB1 связан с доверительными интервалами?', back: 'UCB1 использует верхнюю границу доверительного интервала для выбора действия.', status: 'unseen' },
    { id: 'card-76', front: 'Почему UCB1 считается алгоритмом обучения с подкреплением?', back: 'Он учится на взаимодействиях с окружением, балансирует исследование и использование.', status: 'unseen' },
    { id: 'card-77', front: 'Как реализовать UCB1 в Python?', back: 'Для каждого варианта считать среднюю награду и доверительный интервал, выбирать вариант с max UCB.', status: 'unseen' },
    { id: 'card-78', front: 'Как реализовать Thompson Sampling в Python?', back: 'Для каждого варианта генерировать случайное значение из бета-распределения, выбирать вариант с max значением.', status: 'unseen' },
    { id: 'card-79', front: 'Какие преимущества у байесовского подхода?', back: 'Учет априорных знаний, естественная оценка неопределенности, интерпретируемость.', status: 'unseen' },
    { id: 'card-80', front: 'Какие недостатки у байесовского подхода?', back: 'Вычислительная сложность, необходимость выбора априорных распределений.', status: 'unseen' },
    { id: 'card-81', front: 'Что такое отношение шансов (odds ratio)?', back: 'Отношение шансов успеха в тестовой группе к шансам в контрольной группе.', status: 'unseen' },
    { id: 'card-82', front: 'Как интерпретировать odds ratio?', back: 'OR > 1: тестовая группа лучше; OR < 1: контрольная группа лучше; OR = 1: нет разницы.', status: 'unseen' },
    { id: 'card-83', front: 'Что такое поправка Йейтса в хи-квадрате?', back: 'Поправка для увеличения точности хи-квадрат теста для малых выборок.', status: 'unseen' },
    { id: 'card-84', front: 'Когда использовать поправку Йейтса?', back: 'Для таблиц 2x2 с малыми ожидаемыми частотами (<5).', status: 'unseen' },
    { id: 'card-85', front: 'Что такое центральная предельная теорема (ЦПТ)?', back: 'Теорема, согласно которой выборочное среднее стремится к нормальному распределению при увеличении выборки.', status: 'unseen' },
    { id: 'card-86', front: 'Почему ЦПТ важна для A/B-тестов?', back: 'Она обосновывает использование Z-теста для пропорций при больших выборках.', status: 'unseen' },
    { id: 'card-87', front: 'Что такое нормальное распределение?', back: 'Симметричное распределение, задаваемое средним и стандартным отклонением.', status: 'unseen' },
    { id: 'card-88', front: 'Как проверить нормальность данных?', back: 'Использовать тесты Шапиро-Уилка или Колмогорова-Смирнова, построить Q-Q plot.', status: 'unseen' },
    { id: 'card-89', front: 'Что делать, если данные не нормальны?', back: 'Использовать непараметрические тесты (например, Манна-Уитни).', status: 'unseen' },
    { id: 'card-90', front: 'Что такое гомогенность дисперсий?', back: 'Равенство дисперсий в сравниваемых группах.', status: 'unseen' },
    { id: 'card-91', front: 'Как проверить гомогенность дисперсий?', back: 'Использовать тест Левена или Бартлетта.', status: 'unseen' },
    { id: 'card-92', front: 'Что делать, если дисперсии не равны?', back: 'Использовать модификации t-теста (например, Уэлча).', status: 'unseen' },
    { id: 'card-93', front: 'Что такое ANOVA?', back: 'Метод сравнения средних значений в трех и более группах.', status: 'unseen' },
    { id: 'card-94', front: 'Когда использовать ANOVA?', back: 'Для сравнения нескольких вариантов в A/B/n-тестах.', status: 'unseen' },
    { id: 'card-95', front: 'Что такое множественные сравнения?', back: 'Проблема увеличения вероятности ложноположительных результатов при множественных тестах.', status: 'unseen' },
    { id: 'card-96', front: 'Как корректировать множественные сравнения?', back: 'Использовать поправку Бонферрони или метод Холма.', status: 'unseen' },
    { id: 'card-97', front: 'Что такое ковариаты в A/B-тестах?', back: 'Дополнительные переменные, которые могут влиять на результат.', status: 'unseen' },
    { id: 'card-98', front: 'Как учесть ковариаты в анализе?', back: 'Использовать регрессионные модели (например, логистическую регрессию).', status: 'unseen' },
    { id: 'card-99', front: 'Что такое стратификация в A/B-тестах?', back: 'Разделение пользователей на подгруппы для более точного сравнения.', status: 'unseen' },
    { id: 'card-100', front: 'Как стратификация помогает в тестах?', back: 'Уменьшает вариабельность внутри групп, увеличивает мощность теста.', status: 'unseen' },
    { id: 'card-101', front: 'Что такое последовательный анализ?', back: 'Метод, позволяющий проверять результаты теста по мере поступления данных.', status: 'unseen' },
    { id: 'card-102', front: 'Какие методы последовательного анализа существуют?', back: 'Последовательный тест отношения правдоподобий, метод О\'Брайена-Флеминга.', status: 'unseen' },
    { id: 'card-103', front: 'Что такое бутстрап в статистике?', back: 'Метод оценки распределения статистики путем повторной выборки с заменой.', status: 'unseen' },
    { id: 'card-104', front: 'Как использовать бутстрап в A/B-тестах?', back: 'Для оценки доверительных интервалов разницы метрик без предположений о распределении.', status: 'unseen' },
    { id: 'card-105', front: 'Что такое байесовский фактор?', back: 'Мера относительной поддержки одной гипотезы по сравнению с другой в байесовском анализе.', status: 'unseen' },
    { id: 'card-106', front: 'Как интерпретировать байесовский фактор?', back: 'BF > 1 поддерживает H1, BF < 1 поддерживает H0; чем дальше от 1, тем сильнее поддержка.', status: 'unseen' },
    { id: 'card-107', front: 'Что такое ROC-кривая?', back: 'График, показывающий компромисс между чувствительностью и специфичностью модели.', status: 'unseen' },
    { id: 'card-108', front: 'Как ROC-кривая связана с A/B-тестами?', back: 'Может использоваться для оценки качества классификации вариантов.', status: 'unseen' },
    { id: 'card-109', front: 'Что такое AUC?', back: 'Площадь под ROC-кривой, мера качества классификатора.', status: 'unseen' },
    { id: 'card-110', front: 'Как AUC используется в A/B-тестах?', back: 'Для сравнения эффективности разных вариантов в задачах классификации.', status: 'unseen' },
    { id: 'card-111', front: 'Что такое F-мера?', back: 'Гармоническое среднее точности и полноты, мера качества классификации.', status: 'unseen' },
    { id: 'card-112', front: 'Как F-мера используется в A/B-тестах?', back: 'Для сравнения вариантов в задачах с дисбалансом классов.', status: 'unseen' },
    { id: 'card-113', front: 'Что такое чувствительность (recall)?', back: 'Доля истинных положительных случаев, которые правильно идентифицированы.', status: 'unseen' },
    { id: 'card-114', front: 'Что такое специфичность?', back: 'Доля истинных отрицательных случаев, которые правильно идентифицированы.', status: 'unseen' },
    { id: 'card-115', front: 'Что такое точность (precision)?', back: 'Доля правильно идентифицированных положительных случаев среди всех предсказанных положительных.', status: 'unseen' },
    { id: 'card-116', front: 'Как выбирать между точностью и полнотой?', back: 'Зависит от задачи: для минимизации ложных срабатываний — точность, для максимизации обнаружения — полнота.', status: 'unseen' },
    { id: 'card-117', front: 'Что такое матрица ошибок?', back: 'Таблица, показывающая количество истинных и ложных положительных/отрицательных предсказаний.', status: 'unseen' },
    { id: 'card-118', front: 'Как матрица ошибок используется в A/B-тестах?', back: 'Для визуализации эффективности разных вариантов в задачах классификации.', status: 'unseen' },
    { id: 'card-119', front: 'Что такое дисперсия?', back: 'Мера разброса данных вокруг среднего значения.', status: 'unseen' },
    { id: 'card-120', front: 'Как дисперсия влияет на A/B-тесты?', back: 'Высокая дисперсия требует большего размера выборки для обнаружения эффекта.', status: 'unseen' },
    { id: 'card-121', front: 'Что такое стандартное отклонение?', back: 'Квадратный корень из дисперсии, мера разброса в исходных единицах.', status: 'unseen' },
    { id: 'card-122', front: 'Как стандартное отклонение используется в A/B-тестах?', back: 'Для расчета доверительных интервалов и стандартных ошибок.', status: 'unseen' },
    { id: 'card-123', front: 'Что такое стандартная ошибка?', back: 'Стандартное отклонение выборочного распределения статистики.', status: 'unseen' },
    { id: 'card-124', front: 'Как стандартная ошибка используется в A/B-тестах?', back: 'Для оценки точности оценки среднего и расчета доверительных интервалов.', status: 'unseen' },
    { id: 'card-125', front: 'Что такое корреляция?', back: 'Мера линейной зависимости между двумя переменными.', status: 'unseen' },
    { id: 'card-126', front: 'Как корреляция влияет на A/B-тесты?', back: 'Высокая корреляция между метриками может требовать многомерного анализа.', status: 'unseen' },
    { id: 'card-127', front: 'Что такое ковариация?', back: 'Мера совместной изменчивости двух переменных.', status: 'unseen' },
    { id: 'card-128', front: 'Как ковариация используется в A/B-тестах?', back: 'Для анализа взаимосвязи между метриками и ковариатами.', status: 'unseen' },
    { id: 'card-129', front: 'Что такое линейная регрессия?', back: 'Модель, предсказывающая зависимую переменную как линейную комбинацию независимых.', status: 'unseen' },
    { id: 'card-130', front: 'Как линейная регрессия используется в A/B-тестах?', back: 'Для учета ковариат и стратификации при анализе результатов.', status: 'unseen' },
    { id: 'card-131', front: 'Что такое логистическая регрессия?', back: 'Модель для предсказания вероятности бинарного исхода.', status: 'unseen' },
    { id: 'card-132', front: 'Как логистическая регрессия используется в A/B-тестах?', back: 'Для анализа бинарных метрик (например, конверсии) с учетом ковариат.', status: 'unseen' },
    { id: 'card-133', front: 'Что такое случайный лес?', back: 'Ансамблевый метод, строящий множество деревьев решений.', status: 'unseen' },
    { id: 'card-134', front: 'Как случайный лес используется в A/B-тестах?', back: 'Для анализа нелинейных эффектов и взаимодействий между переменными.', status: 'unseen' },
    { id: 'card-135', front: 'Что такое градиентный бустинг?', back: 'Ансамблевый метод, последовательно строящий модели для исправления ошибок предыдущих.', status: 'unseen' },
    { id: 'card-136', front: 'Как градиентный бустинг используется в A/B-тестах?', back: 'Для анализа сложных зависимостей в данных и предсказания эффектов.', status: 'unseen' },
    { id: 'card-137', front: 'Что такое кластеризация?', back: 'Метод группировки схожих объектов без предварительных меток.', status: 'unseen' },
    { id: 'card-138', front: 'Как кластеризация используется в A/B-тестах?', back: 'Для сегментации пользователей перед тестированием или анализа результатов.', status: 'unseen' },
    { id: 'card-139', front: 'Что такое метод главных компонент (PCA)?', back: 'Метод снижения размерности путем проецирования данных на ортогональные оси.', status: 'unseen' },
    { id: 'card-140', front: 'Как PCA используется в A/B-тестах?', back: 'Для визуализации многомерных данных или уменьшения количества переменных.', status: 'unseen' },
    { id: 'card-141', front: 'Что такое t-SNE?', back: 'Метод визуализации многомерных данных в двумерном или трехмерном пространстве.', status: 'unseen' },
    { id: 'card-142', front: 'Как t-SNE используется в A/B-тестах?', back: 'Для визуализации различий между группами пользователей или вариантами.', status: 'unseen' },
    { id: 'card-143', front: 'Что такое UMAP?', back: 'Метод снижения размерности, сохраняющий как локальную, так и глобальную структуру данных.', status: 'unseen' },
    { id: 'card-144', front: 'Как UMAP используется в A/B-тестах?', back: 'Аналогично t-SNE, но с лучшей производительностью на больших данных.', status: 'unseen' },
    { id: 'card-145', front: 'Что такое кросс-валидация?', back: 'Метод оценки моделей путем разделения данных на обучающую и тестовую выборки.', status: 'unseen' },
    { id: 'card-146', front: 'Как кросс-валидация используется в A/B-тестах?', back: 'Для проверки устойчивости моделей, предсказывающих эффект теста.', status: 'unseen' },
    { id: 'card-147', front: 'Что такое переобучение?', back: 'Когда модель слишком точно подстраивается под обучающие данные и плохо обобщается.', status: 'unseen' },
    { id: 'card-148', front: 'Как избежать переобучения в A/B-тестах?', back: 'Использовать кросс-валидацию, регуляризацию, уменьшать сложность моделей.', status: 'unseen' },
  { id: 'card-149', front: 'Что такое регуляризация?', back: 'Метод предотвращения переобучения путем добавления штрафа за сложность модели.', status: 'unseen' },
    { id: 'card-150', front: 'Как регуляризация используется в A/B-тестах?', back: 'В регрессионных моделях для анализа результатов с множеством ковариат.', status: 'unseen' },
    { id: 'card-151', front: 'Что такое L1-регуляризация (Lasso)?', back: 'Регуляризация, которая может обнулять коэффициенты, выполняя отбор признаков.', status: 'unseen' },
    { id: 'card-152', front: 'Как Lasso используется в A/B-тестах?', back: 'Для выбора наиболее важных ковариат при анализе результатов теста.', status: 'unseen' },
    { id: 'card-153', front: 'Что такое L2-регуляризация (Ridge)?', back: 'Регуляризация, уменьшающая коэффициенты, но не обнуляющая их.', status: 'unseen' },
    { id: 'card-154', front: 'Как Ridge используется в A/B-тестах?', back: 'Для стабилизации оценок в регрессионных моделях при мультиколлинеарности.', status: 'unseen' },
    { id: 'card-155', front: 'Что такое Elastic Net?', back: 'Комбинация L1 и L2 регуляризации.', status: 'unseen' },
    { id: 'card-156', front: 'Как Elastic Net используется в A/B-тестах?', back: 'Когда нужно сочетать отбор признаков и уменьшение коэффициентов.', status: 'unseen' },
    { id: 'card-157', front: 'Что такое мультиколлинеарность?', back: 'Высокая корреляция между независимыми переменными в модели.', status: 'unseen' },
    { id: 'card-158', front: 'Как мультиколлинеарность влияет на A/B-тесты?', back: 'Может сделать оценки коэффициентов нестабильными и трудными для интерпретации.', status: 'unseen' },
    { id: 'card-159', front: 'Что такое гетероскедастичность?', back: 'Непостоянство дисперсии ошибок модели.', status: 'unseen' },
    { id: 'card-160', front: 'Как гетероскедастичность влияет на A/B-тесты?', back: 'Может привести к неэффективным оценкам и некорректным доверительным интервалам.', status: 'unseen' },
    { id: 'card-161', front: 'Что такое гомоскедастичность?', back: 'Постоянство дисперсии ошибок модели.', status: 'unseen' },
    { id: 'card-162', front: 'Почему гомоскедастичность важна в A/B-тестах?', back: 'Обеспечивает эффективность оценок и корректность статистических тестов.', status: 'unseen' },
    { id: 'card-163', front: 'Что такое остатки в регрессии?', back: 'Разница между наблюдаемыми и предсказанными значениями.', status: 'unseen' },
    { id: 'card-164', front: 'Как анализировать остатки в A/B-тестах?', back: 'Для проверки допущений модели (нормальность, гомоскедастичность).', status: 'unseen' },
    { id: 'card-165', front: 'Что такое Q-Q plot?', back: 'График для проверки нормальности распределения.', status: 'unseen' },
    { id: 'card-166', front: 'Как Q-Q plot используется в A/B-тестах?', back: 'Для проверки нормальности остатков регрессионных моделей.', status: 'unseen' },
    { id: 'card-167', front: 'Что такое критерий согласия?', back: 'Тест для проверки соответствия данных определенному распределению.', status: 'unseen' },
    { id: 'card-168', front: 'Как критерии согласия используются в A/B-тестах?', back: 'Для проверки нормальности данных перед применением параметрических тестов.', status: 'unseen' },
    { id: 'card-169', front: 'Что такое критерий Шапиро-Уилка?', back: 'Тест для проверки нормальности распределения.', status: 'unseen' },
    { id: 'card-170', front: 'Как критерий Шапиро-Уилка используется в A/B-тестах?', back: 'Для проверки нормальности данных перед t-тестом или ANOVA.', status: 'unseen' },
    { id: 'card-171', front: 'Что такое критерий Колмогорова-Смирнова?', back: 'Тест для сравнения распределений или проверки соответствия теоретическому распределению.', status: 'unseen' },
    { id: 'card-172', front: 'Как критерий Колмогорова-Смирнова используется в A/B-тестах?', back: 'Для сравнения распределений метрик между группами.', status: 'unseen' },
    { id: 'card-173', front: 'Что такое критерий Левена?', back: 'Тест для проверки равенства дисперсий в группах.', status: 'unseen' },
    { id: 'card-174', front: 'Как критерий Левена используется в A/B-тестах?', back: 'Для проверки гомогенности дисперсий перед t-тестом или ANOVA.', status: 'unseen' },
    { id: 'card-175', front: 'Что такое критерий Бартлетта?', back: 'Тест для проверки равенства дисперсий, чувствительный к отклонениям от нормальности.', status: 'unseen' },
    { id: 'card-176', front: 'Как критерий Бартлетта используется в A/B-тестах?', back: 'Альтернатива критерию Левена при нормальных данных.', status: 'unseen' },
    { id: 'card-177', front: 'Что такое критерий Фридмана?', back: 'Непараметрический тест для сравнения трех и более связанных групп.', status: 'unseen' },
    { id: 'card-178', front: 'Как критерий Фридмана используется в A/B-тестах?', back: 'Для сравнения нескольких вариантов при ненормальных данных.', status: 'unseen' },
    { id: 'card-179', front: 'Что такое критерий Крускала-Уоллиса?', back: 'Непараметрический аналог ANOVA для независимых групп.', status: 'unseen' },
    { id: 'card-180', front: 'Как критерий Крускала-Уоллиса используется в A/B-тестах?', back: 'Для сравнения нескольких вариантов при ненормальных данных.', status: 'unseen' },
    { id: 'card-181', front: 'Что такое критерий знаков?', back: 'Непараметрический тест для сравнения двух связанных выборок.', status: 'unseen' },
    { id: 'card-182', front: 'Как критерий знаков используется в A/B-тестах?', back: 'Для анализа парных данных при ненормальных распределениях.', status: 'unseen' },
    { id: 'card-183', front: 'Что такое критерий Уилкоксона?', back: 'Непараметрический тест для сравнения двух связанных выборок (аналог парного t-теста).', status: 'unseen' },
    { id: 'card-184', front: 'Как критерий Уилкоксона используется в A/B-тестах?', back: 'Для анализа парных данных при ненормальных распределениях.', status: 'unseen' },
    { id: 'card-185', front: 'Что такое коэффициент корреляции Пирсона?', back: 'Мера линейной зависимости между двумя переменными.', status: 'unseen' },
    { id: 'card-186', front: 'Как коэффициент Пирсона используется в A/B-тестах?', back: 'Для анализа связи между метриками и ковариатами.', status: 'unseen' },
    { id: 'card-187', front: 'Что такое коэффициент корреляции Спирмена?', back: 'Мера монотонной зависимости между двумя переменными.', status: 'unseen' },
    { id: 'card-188', front: 'Как коэффициент Спирмена используется в A/B-тестах?', back: 'Для анализа нелинейных зависимостей между метриками.', status: 'unseen' },
    { id: 'card-189', front: 'Что такое коэффициент корреляции Кендалла?', back: 'Мера ранговой корреляции, устойчивая к выбросам.', status: 'unseen' },
    { id: 'card-190', front: 'Как коэффициент Кендалла используется в A/B-тестах?', back: 'Для анализа зависимостей при небольших выборках с выбросами.', status: 'unseen' },
    { id: 'card-191', front: 'Что такое коэффициент детерминации R²?', back: 'Доля дисперсии зависимой переменной, объясненная моделью.', status: 'unseen' },
    { id: 'card-192', front: 'Как R² используется в A/B-тестах?', back: 'Для оценки качества регрессионных моделей при анализе результатов.', status: 'unseen' },
    { id: 'card-193', front: 'Что такое скорректированный R²?', back: 'R² с поправкой на количество предикторов в модели.', status: 'unseen' },
    { id: 'card-194', front: 'Как скорректированный R² используется в A/B-тестах?', back: 'Для сравнения моделей с разным количеством предикторов.', status: 'unseen' },
    { id: 'card-195', front: 'Что такое AIC (информационный критерий Акаике)?', back: 'Мера качества модели с учетом её сложности.', status: 'unseen' },
    { id: 'card-196', front: 'Как AIC используется в A/B-тестах?', back: 'Для выбора лучшей модели при анализе результатов теста.', status: 'unseen' },
    { id: 'card-197', front: 'Что такое BIC (байесовский информационный критерий)?', back: 'Аналогичен AIC, но с более строгим штрафом за сложность модели.', status: 'unseen' },
    { id: 'card-198', front: 'Как BIC используется в A/B-тестах?', back: 'Для выбора лучшей модели, особенно при больших выборках.', status: 'unseen' },
    { id: 'card-199', front: 'Что такое кросс-энтропия?', back: 'Мера расхождения между распределениями, часто используемая в классификации.', status: 'unseen' },
    { id: 'card-200', front: 'Как кросс-энтропия используется в A/B-тестах?', back: 'Для оценки качества моделей классификации при анализе бинарных метрик.', status: 'unseen' },

{
  id: 'card-201',
  front: 'Какова формула для оценки конверсии в A/B-тесте?',
  back: 'Формула: C = K / N, где:\n- C — конверсия,\n- K — количество успехов (например, покупок),\n- N — общее число пользователей.\n\nЭта формула используется для подсчёта доли успешных исходов среди всех испытуемых. Применяется на этапе сбора данных и анализа результатов теста.',
  status: 'unseen'
},
{
  id: 'card-202',
  front: 'Как рассчитывается относительное изменение конверсии?',
  back: 'Формула: Δ = (C_B - C_A) / C_A * 100%, где:\n- C_B — конверсия группы B,\n- C_A — конверсия группы A.\n\nПоказывает процентное изменение эффективности новой версии относительно контрольной. Используется для интерпретации практических результатов теста.',
  status: 'unseen'
},
{
  id: 'card-203',
  front: 'Как найти абсолютное изменение конверсии?',
  back: 'Формула: Δ_abs = C_B - C_A, где:\n- C_B — конверсия группы B,\n- C_A — конверсия группы A.\n\nПоказывает разницу между конверсиями двух групп. Используется при анализе статистической значимости различий.',
  status: 'unseen'
},
{
  id: 'card-204',
  front: 'Что такое Z-тест для пропорций?',
  back: 'Формула: Z = (p₁ - p₂) / sqrt(p*(1-p)*(1/n₁ + 1/n₂)), где:\n- p₁, p₂ — конверсии групп A и B,\n- n₁, n₂ — размеры выборок,\n- p = (x₁ + x₂) / (n₁ + n₂), где x₁, x₂ — число успехов.\n\nИспользуется для проверки гипотезы о равенстве пропорций (конверсий). Подходит для больших выборок.',
  status: 'unseen'
},
{
  id: 'card-205',
  front: 'Как определить p-value в Z-тесте?',
  back: 'p-value = 2 * Φ(-|Z|), где:\n- Φ — кумулятивная функция стандартного нормального распределения,\n- Z — значение Z-статистики.\n\nОпределяет вероятность наблюдать такие или более экстремальные данные при нулевой гипотезе. Используется для принятия решения о значимости различий.',
  status: 'unseen'
},
{
  id: 'card-206',
  front: 'Как рассчитать доверительный интервал для конверсии?',
  back: 'Формула: CI = p ± Z * sqrt(p*(1-p)/n), где:\n- p — наблюдаемая доля успехов,\n- Z — z-значение для нужного уровня доверия (например, 1.96 для 95%),\n- n — размер выборки.\n\nПоказывает диапазон, в котором истинное значение конверсии находится с заданной вероятностью. Используется для интерпретации неопределённости.',
  status: 'unseen'
},
{
  id: 'card-207',
  front: 'Как вычислить статистическую мощность теста?',
  back: 'Мощность = 1 - β, где β — вероятность ошибки II рода.\n\nМощность показывает способность теста обнаруживать эффект, если он существует. Обычно рекомендуется ≥80%. Используется при планировании размера выборки.',
  status: 'unseen'
},
{
  id: 'card-208',
  front: 'Как рассчитать необходимый объём выборки для A/B-теста?',
  back: 'Формула: n = (Z_α/2 + Z_β)^2 * p*(1-p) / d², где:\n- Z_α/2 — z-значение для уровня значимости α (обычно 0.05),\n- Z_β — z-значение для мощности (обычно 0.8 → Z ≈ 0.84),\n- p — средняя конверсия,\n- d — минимальный детектируемый эффект (MDE).\n\nИспользуется для предварительного расчёта количества участников на каждую группу.',
  status: 'unseen'
},
{
  id: 'card-209',
  front: 'Что такое t-тест в контексте A/B-тестирования?',
  back: 'Формула: t = (μ₁ - μ₂) / sqrt((s₁²/n₁) + (s₂²/n₂)), где:\n- μ₁, μ₂ — средние значения групп,\n- s₁, s₂ — стандартные отклонения,\n- n₁, n₂ — размеры выборок.\n\nПрименяется, когда данные имеют нормальное распределение, особенно для малых выборок. Проверяет равенство средних.',
  status: 'unseen'
},
{
  id: 'card-210',
  front: 'Как работает тест Манна-Уитни?',
  back: 'Тест Манна-Уитни сравнивает ранги между двумя группами. Не требует нормальности.\n\nФормула не простая, но идея — считать, сколько раз элементы из одной группы больше элементов другой.\n\nИспользуется для непараметрической проверки различий между группами, особенно при наличии выбросов.',
  status: 'unseen'
},
{
  id: 'card-211',
  front: 'Что такое байесовский подход в A/B-тестировании?',
  back: 'Формула: P(H|D) = P(D|H)*P(H) / P(D), где:\n- P(H|D) — апостериорная вероятность гипотезы,\n- P(D|H) — правдоподобие данных,\n- P(H) — априорная вероятность,\n- P(D) — маргинальная вероятность данных.\n\nБайесовский подход позволяет обновлять вероятность гипотезы по мере получения новых данных. Подходит для онлайн-обновления и меньших выборок.',
  status: 'unseen'
},
{
  id: 'card-212',
  front: 'Как выглядит модель бета-биномиального теста?',
  back: 'Априорное распределение: Beta(α, β)\nНаблюдения: Binomial(n, p)\nАпостериорное: Beta(α + k, β + n - k), где:\n- k — число успехов,\n- n — число испытаний.\n\nИспользуется для моделирования неопределенности в конверсии. Удобен в байесовских A/B-тестах.',
  status: 'unseen'
},
{
  id: 'card-213',
  front: 'Как сравнить две бета-распределенные группы?',
  back: 'Метод: сэмплирование из апостериорных Beta-распределений для каждой группы и подсчёт вероятности того, что p_B > p_A.\n\nПример:\np_A ~ Beta(α1 + k1, β1 + n1 - k1)\np_B ~ Beta(α2 + k2, β2 + n2 - k2)\nprob = mean(p_B > p_A)\n\nИспользуется в байесовском подходе для принятия решений без жёстких порогов p-value.',
  status: 'unseen'
},
{
  id: 'card-214',
  front: 'Как рассчитать вероятность того, что вариант B лучше A в байесовском тесте?',
  back: 'Формула: prob = ∫_{p_A < p_B} P(p_A) * P(p_B) dp_A dp_B\n\nНа практике реализуется через численное интегрирование или MCMC-методы. Также можно использовать метод сэмплирования из апостериорных распределений.\n\nИспользуется в байесовском выводе для интерпретации результатов теста в терминах вероятностей.',
  status: 'unseen'
},
{
  id: 'card-215',
  front: 'Что такое credible interval в байесовском A/B-тесте?',
  back: 'Диапазон, в котором апостериорная вероятность параметра лежит с заданной вероятностью (например, 95%).\n\nВ отличие от доверительного интервала, имеет прямую вероятностную интерпретацию: «С вероятностью 95% истинное значение лежит в этом интервале».\n\nИспользуется в байесовских методах для оценки неопределённости.',
  status: 'unseen'
},
{
  id: 'card-216',
  front: 'Как работает правило "ожидаемого ущерба" в байесовском A/B-тесте?',
  back: 'Формула: Expected Loss = E[max(0, p_A - p_B)]\n\nВычисляет ожидаемый ущерб от выбора худшего варианта. Если он ниже порога, можно принимать решение.\n\nИспользуется в бизнес-контексте для минимизации потерь при принятии решений.',
  status: 'unseen'
},
{
  id: 'card-217',
  front: 'Как выбрать априорное распределение в байесовском тесте?',
  back: 'Если есть исторические данные, можно использовать информативный априор, например:\nBeta(α, β), где α = success_prev, β = total_prev - success_prev\n\nЕсли данных нет, используют слабоинформативные априоры, например:\nBeta(1, 1) — равномерное распределение.\n\nВыбор влияет на скорость сходимости и чувствительность теста.',
  status: 'unseen'
},
{
  id: 'card-218',
  front: 'Как работает байесовский фактор (Bayes Factor)?',
  back: 'BF = P(D|H1) / P(D|H0), где:\n- H0 — гипотеза об отсутствии различий,\n- H1 — гипотеза о наличии различий.\n\nBF > 1 говорит в пользу H1. Чем выше, тем сильнее доказательства.\n\nИспользуется для сравнения моделей в байесовском подходе.',
  status: 'unseen'
},
{
  id: 'card-219',
  front: 'Что такое регрессионная коррекция в A/B-тестировании?',
  back: 'Модель: y_i = β0 + β1*Treatment_i + ε_i, где:\n- y_i — метрика пользователя i,\n- Treatment_i — флаг принадлежности к экспериментальной группе (0 или 1),\n- β1 — оценка эффекта.\n\nПозволяет контролировать ковариаты и повышает точность оценки эффекта.',
  status: 'unseen'
},
{
  id: 'card-220',
  front: 'Как рассчитать относительный риск (relative risk) в A/B-тесте?',
  back: 'Формула: RR = C_B / C_A, где:\n- C_B — конверсия группы B,\n- C_A — конверсия группы A.\n\nRR > 1 означает, что вариант B лучше A. Используется в медицинских и маркетинговых исследованиях.',
  status: 'unseen'
},
{
  id: 'card-221',
  front: 'Как вычислить отношение шансов (odds ratio) в A/B-тесте?',
  back: 'Формула: OR = (K_B / (N_B - K_B)) / (K_A / (N_A - K_A)), где:\n- K_A, K_B — число успехов в группах,\n- N_A, N_B — размеры групп.\n\nOR показывает, во сколько раз выше шансы успеха в одной группе относительно другой. Используется в логистической регрессии и клинических тестах.',
  status: 'unseen'
},
{
  id: 'card-222',
  front: 'Что такое перекрытие выборок в A/B-тесте?',
  back: 'Неформальная формула: % перекрытия = (кол-во пользователей в обеих группах) / (общее кол-во пользователей)\n\nПерекрытие может нарушать независимость выборок и искажать результаты. В идеале должно быть 0%',
  status: 'unseen'
},
{
  id: 'card-223',
  front: 'Как рассчитать коэффициент вариации для A/B-теста?',
  back: 'Формула: CV = σ / μ, где:\n- σ — стандартное отклонение,\n- μ — среднее значение.\n\nCV показывает относительную изменчивость метрики. Полезен для сравнения метрик с разными масштабами.',
  status: 'unseen'
},
{
  id: 'card-224',
  front: 'Как выглядит формула ANOVA для нескольких вариантов A/B-теста?',
  back: 'F = MS_between / MS_within, где:\n- MS_between — средний квадрат между группами,\n- MS_within — средний квадрат внутри групп.\n\nИспользуется при тестировании более чем двух вариантов (A/B/C и т.д.).',
  status: 'unseen'
},
{
  id: 'card-225',
  front: 'Как рассчитать эффект Крамера V для категориальных данных?',
  back: 'Формула: V = sqrt(χ² / (n * min(r-1, c-1))), где:\n- χ² — статистика хи-квадрат,\n- n — общее число наблюдений,\n- r, c — количество строк и столбцов таблицы.\n\nИспользуется для оценки силы связи между категориальными переменными.',
  status: 'unseen'
},
{
  id: 'card-226',
  front: 'Что такое Uplift-моделирование в A/B-тестировании?',
  back: 'Формула: Uplift = P(Y=1 | T=1) - P(Y=1 | T=0), где:\n- Y — целевое событие,\n- T — флаг воздействия (тест/контроль).\n\nИспользуется для оценки индивидуального эффекта воздействия, а не только среднего.',
  status: 'unseen'
},
{
  id: 'card-227',
  front: 'Как выглядит формула для оценки ROI в A/B-тесте?',
  back: 'Формула: ROI = (выигрыш от изменения - затраты на тестирование) / затраты на тестирование\n\nИспользуется для экономической оценки выгодности внедрения изменений.',
  status: 'unseen'
},
{
  id: 'card-228',
  front: 'Как рассчитать стоимость ошибочного решения в A/B-тесте?',
  back: 'Формула: Cost = P(ошибка) × величина убытка от ошибочного выбора\n\nИспользуется в байесовском подходе для минимизации рисков.',
  status: 'unseen'
},
{
  id: 'card-229',
  front: 'Что такое MDE (минимальный детектируемый эффект)?',
  back: 'Формула: MDE = Z * sqrt(p*(1-p)*(1/n₁ + 1/n₂)), где:\n- Z — комбинация уровней α и β,\n- p — средняя конверсия,\n- n₁, n₂ — размеры выборок.\n\nMDE — это минимальный эффект, который тест способен обнаружить с заданной мощностью.',
  status: 'unseen'
},
{
  id: 'card-230',
  front: 'Как выглядит формула для отношения правдоподобия в A/B-тесте?',
  back: 'Формула: LR = P(data | H1) / P(data | H0)\n\nГде H1 — гипотеза о наличии эффекта, H0 — гипотеза об отсутствии.\n\nИспользуется в байесовском подходе и для оценки силы доказательств.',
  status: 'unseen'
},
{
  id: 'card-231',
  front: 'Как рассчитать среднее время до события в A/B-тесте?',
  back: 'Формула: MTTF = Σ(t_i) / n, где:\n- t_i — время до события для пользователя i,\n- n — общее число пользователей.\n\nИспользуется при анализе временных метрик, таких как time to purchase.',
  status: 'unseen'
},
{
  id: 'card-232',
  front: 'Как оценить выживаемость в A/B-тесте?',
  back: 'Формула: S(t) = P(T > t) — вероятность того, что событие произойдет позже времени t.\n\nИспользуется в анализе выживаемости, особенно при работе с churn rate и retention.',
  status: 'unseen'
},
{
  id: 'card-233',
  front: 'Как рассчитать среднюю абсолютную ошибку (MAE) в A/B-тесте?',
  back: 'Формула: MAE = (Σ|y_i - ŷ_i|) / n, где:\n- y_i — фактические значения,\n- ŷ_i — прогнозируемые значения,\n- n — число наблюдений.\n\nИспользуется при оценке качества моделей, используемых в A/B-тестировании.',
  status: 'unseen'
},
{
  id: 'card-234',
  front: 'Как рассчитать RMSE в A/B-тесте?',
  back: 'Формула: RMSE = sqrt(Σ(y_i - ŷ_i)² / n), где:\n- y_i — фактические значения,\n- ŷ_i — прогнозируемые значения,\n- n — число наблюдений.\n\nRMSE усиливает влияние больших ошибок. Используется для оценки точности моделей.',
  status: 'unseen'
},
{
  id: 'card-235',
  front: 'Как рассчитать коэффициент детерминации R²?',
  back: 'Формула: R² = 1 - SS_res / SS_tot, где:\n- SS_res — сумма квадратов остатков,\n- SS_tot — общая сумма квадратов.\n\nR² показывает, насколько хорошо модель объясняет данные. Используется в регрессионном анализе A/B-тестов.',
  status: 'unseen'
},
{
  id: 'card-236',
  front: 'Как выглядит формула для оценки среднего взвешенного в A/B-тесте?',
  back: 'Формула: w_avg = Σ(w_i * x_i) / Σw_i, где:\n- w_i — веса (например, число пользователей),\n- x_i — значения метрик.\n\nИспользуется при объединении данных из разных источников или периодов.',
  status: 'unseen'
},
{
  id: 'card-237',
  front: 'Как рассчитать среднеквадратическое отклонение (SD)?',
  back: 'Формула: SD = sqrt(Σ(x_i - μ)² / n), где:\n- x_i — значения метрики,\n- μ — среднее,\n- n — число наблюдений.\n\nSD используется для измерения разброса данных вокруг среднего.',
  status: 'unseen'
},
{
  id: 'card-238',
  front: 'Как выглядит формула для оценки средней ошибки (standard error)?',
  back: 'Формула: SE = σ / sqrt(n), где:\n- σ — стандартное отклонение,\n- n — размер выборки.\n\nSE используется для построения доверительных интервалов и проверки гипотез.',
  status: 'unseen'
},
{
  id: 'card-239',
  front: 'Как рассчитать ковариацию между двумя метриками?',
  back: 'Формула: Cov(X,Y) = Σ((x_i - x̄)(y_i - ȳ)) / (n - 1)\n\nИспользуется для понимания направления взаимосвязи между метриками.',
  status: 'unseen'
},
{
  id: 'card-240',
  front: 'Как выглядит формула для коэффициента корреляции Пирсона?',
  back: 'Формула: r = Cov(X,Y) / (σ_X * σ_Y), где:\n- Cov(X,Y) — ковариация,\n- σ_X, σ_Y — стандартные отклонения.\n\nr ∈ [-1; 1]. Используется для оценки силы линейной зависимости между метриками.',
  status: 'unseen'
},
{
  id: 'card-241',
  front: 'Как рассчитать log-loss в A/B-тесте?',
  back: 'Формула: L = - (1/n) Σ [y_i * log(p_i) + (1 - y_i) * log(1 - p_i)], где:\n- y_i — истинные значения (0 или 1),\n- p_i — предсказанные вероятности.\n\nИспользуется в оценке качества вероятностных моделей, часто применяющихся в uplift-моделировании.',
  status: 'unseen'
},
{
  id: 'card-242',
  front: 'Как рассчитать precision в A/B-тесте?',
  back: 'Формула: Precision = TP / (TP + FP), где:\n- TP — истинно положительные,\n- FP — ложно положительные.\n\nPrecision показывает, насколько точно модель или тест выявляет положительные случаи.',
  status: 'unseen'
},
{
  id: 'card-243',
  front: 'Как рассчитать recall в A/B-тесте?',
  back: 'Формула: Recall = TP / (TP + FN), где:\n- TP — истинно положительные,\n- FN — ложно отрицательные.\n\nRecall показывает, насколько полно модель или тест находит положительные случаи.',
  status: 'unseen'
},
{
  id: 'card-244',
  front: 'Как рассчитать F1-score в A/B-тесте?',
  back: 'Формула: F1 = 2 * (precision * recall) / (precision + recall)\n\nF1 — гармоническое среднее precision и recall. Используется при несбалансированных классах.',
  status: 'unseen'
},
{
  id: 'card-245',
  front: 'Как выглядит формула для ROC-AUC?',
  back: 'ROC-AUC — площадь под ROC-кривой, которая строится по TPR и FPR на разных порогах.\n\nЗначение AUC ∈ [0; 1]. Чем выше, тем лучше модель разделяет классы. Используется в оценке качества бинарных классификаторов в A/B-тестах.',
  status: 'unseen'
},
{
  id: 'card-246',
  front: 'Как рассчитать матрицу ошибок в A/B-тесте?',
  back: 'Матрица ошибок (confusion matrix):\n[[TN, FP],\n [FN, TP]]\n\nГде:\n- TN — истинно отрицательные,\n- FP — ложно положительные,\n- FN — ложно отрицательные,\n- TP — истинно положительные.\n\nИспользуется для расчёта метрик качества модели.',
  status: 'unseen'
},
{
  id: 'card-247',
  front: 'Как выглядит формула для TPR (True Positive Rate)?',
  back: 'Формула: TPR = TP / (TP + FN)\n\nТакже называется recall или sensitivity. Показывает, какой процент реальных положительных случаев был правильно определён.',
  status: 'unseen'
},
{
  id: 'card-248',
  front: 'Как рассчитать FPR (False Positive Rate)?',
  back: 'Формула: FPR = FP / (FP + TN)\n\nПоказывает, какой процент реальных отрицательных случаев был ошибочно определён как положительные.',
  status: 'unseen'
},
{
  id: 'card-249',
  front: 'Как выглядит формула для Gini-коэффициента в A/B-тесте?',
  back: 'Формула: Gini = 2*AUC - 1\n\nGini показывает, насколько хорошо модель отличает классы. Используется в оценке качества бинарных моделей.',
  status: 'unseen'
},
{
  id: 'card-250',
  front: 'Как рассчитать lift в A/B-тесте?',
  back: 'Формула: Lift = (TP / (TP + FP)) / (P / Total), где:\n- TP / (TP + FP) — precision,\n- P / Total — доля положительных в популяции.\n\nLift показывает, насколько лучше модель, чем случайный выбор. Используется в оценке эффективности сегментации.',
  status: 'unseen'
},


{
  id: 'card-251',
  front: 'Как рассчитывается среднее взвешенное конверсии?',
  back: 'Формула: w_avg = Σ(n_i * c_i) / Σn_i, где:\n- n_i — размер выборки,\n- c_i — конверсия.\n\nИспользуется при агрегации конверсий из разных групп или источников.',
  status: 'unseen'
},
{
  id: 'card-252',
  front: 'Как выглядит формула для оценки дельты между медианами?',
  back: 'Δ_median = median_B - median_A\n\nПрименяется, когда данные не нормальны или есть выбросы. Альтернатива сравнению средних.',
  status: 'unseen'
},
{
  id: 'card-253',
  front: 'Что такое правило "горизонтального тестирования"?',
  back: 'Неформальная формула: test_duration ≥ 7 дней (или полный цикл пользовательской активности)\n\nПомогает учесть временные факторы (например, дневные/недельные циклы). Используется при планировании длительности теста.',
  status: 'unseen'
},
{
  id: 'card-254',
  front: 'Как рассчитать коэффициент вариации конверсии?',
  back: 'CV = σ / μ, где:\n- σ — стандартное отклонение конверсии,\n- μ — средняя конверсия.\n\nПоказывает относительную стабильность метрики. Полезен для выбора наиболее надёжной метрики.',
  status: 'unseen'
},
{
  id: 'card-255',
  front: 'Как работает метод bootstrap в A/B-тестировании?',
  back: 'Метод: случайная выборка с возвратом из исходных данных, вычисление нужной статистики много раз.\n\nИспользуется для оценки неопределённости без предположений о распределении.',
  status: 'unseen'
},
{
  id: 'card-256',
  front: 'Как рассчитать доверительный интервал через bootstrap?',
  back: 'Метод: взять B ресэмплированных выборок, посчитать статистику, взять α/2 и 1–α/2 квантили.\n\nНапример, для 95% CI: 2.5%-й и 97.5%-й перцентили.\n\nИспользуется, когда классические методы неприменимы.',
  status: 'unseen'
},
{
  id: 'card-257',
  front: 'Как рассчитать средний чек в A/B-тесте?',
  back: 'Формула: avg_order = total_revenue / orders_count\n\navg_order — средний чек,\ntotal_revenue — общая выручка,\norders_count — количество заказов.\n\nИспользуется как метрика в e-commerce A/B-тестах.',
  status: 'unseen'
},
{
  id: 'card-258',
  front: 'Как оценить ARPU в A/B-тесте?',
  back: 'Формула: ARPU = total_revenue / active_users\n\nARPU — доход на пользователя,\ntotal_revenue — выручка,\nactive_users — число активных пользователей.\n\nИспользуется в продуктовой аналитике и monetization-экспериментах.',
  status: 'unseen'
},
{
  id: 'card-259',
  front: 'Как рассчитать ARPPU в A/B-тесте?',
  back: 'Формула: ARPPU = total_revenue / paying_users\n\nARPPU — доход на платящего пользователя,\ntotal_revenue — выручка,\npaying_users — число платящих пользователей.\n\nИспользуется в monetization-тестах.',
  status: 'unseen'
},
{
  id: 'card-260',
  front: 'Как выглядит формула для LTV в A/B-тесте?',
  back: 'LTV = ARPU × lifetime_days\n\nlifetime_days — среднее время жизни пользователя,\nARPU — доход на пользователя.\n\nИспользуется при анализе долгосрочных эффектов изменений.',
  status: 'unseen'
},
{
  id: 'card-261',
  front: 'Как рассчитать churn rate?',
  back: 'Формула: Churn = lost_users / total_users_at_start\n\nlost_users — число потерянных пользователей,\ntotal_users_at_start — число пользователей в начале периода.\n\nИспользуется в retention-тестах.',
  status: 'unseen'
},
{
  id: 'card-262',
  front: 'Как определить retention rate?',
  back: 'Формула: Retention = retained_users / total_users_at_start\n\nretained_users — число вернувшихся пользователей,\ntotal_users_at_start — число пользователей в начале.\n\nИспользуется при измерении лояльности.',
  status: 'unseen'
},
{
  id: 'card-263',
  front: 'Как выглядит формула для uplift моделирования через T-learner?',
  back: 'T-learner:\nμ₁(x) = E[Y | T=1, X=x]\nμ₀(x) = E[Y | T=0, X=x]\nuplift(x) = μ₁(x) - μ₀(x)\n\nГде Y — целевая метрика,\nT — флаг группы,\nX — ковариаты.\n\nИспользуется для оценки индивидуальных эффектов воздействия.',
  status: 'unseen'
},
{
  id: 'card-264',
  front: 'Как рассчитать uplift через S-learner?',
  back: 'S-learner:\nμ(x, t) = E[Y | X=x, T=t]\nuplift(x) = μ(x, 1) - μ(x, 0)\n\nГде T — флаг группы,\nX — ковариаты,\nY — метрика.\n\nЕщё один способ моделирования индивидуального эффекта изменения.',
  status: 'unseen'
},
{
  id: 'card-265',
  front: 'Как работает CATE в uplift-моделировании?',
  back: 'CATE = E[Y(1) - Y(0) | X=x], где:\n- Y(1), Y(0) — потенциальные исходы под воздействием и без,\n- X — ковариаты.\n\nCATE показывает, насколько конкретный пользователь может быть затронут изменением.',
  status: 'unseen'
},
{
  id: 'card-266',
  front: 'Как выглядит формула для uplift через метрику Qini?',
  back: 'Qini = ∫[E[Y(1) - Y(0) | score ≥ s] * P(score ≥ s)] ds\n\nМера качества uplift-модели. Чем выше значение, тем лучше модель ранжирует пользователей.',
  status: 'unseen'
},
{
  id: 'card-267',
  front: 'Как рассчитать Qini coefficient?',
  back: 'Qini_coeff = Area under Qini curve / Area under random curve\n\nКоэффициент > 1 говорит о том, что модель лучше случайной. Используется в uplift-оценке.',
  status: 'unseen'
},
{
  id: 'card-268',
  front: 'Как выглядит формула для AUUC?',
  back: 'AUUC = площадь под кривой uplift по рангам\n\nAUUC — area under the uplift curve. Используется как метрика качества uplift-модели.',
  status: 'unseen'
},
{
  id: 'card-269',
  front: 'Как рассчитать uplift через Kullback-Leibler divergence?',
  back: 'KL_uplift = D_KL(P(Y|T=1) || P(Y|T=0))\n\nИзмеряет различие между распределениями метрик в контрольной и экспериментальной группах.',
  status: 'unseen'
},
{
  id: 'card-270',
  front: 'Как выглядит формула для KL-дивергенции?',
  back: 'D_KL(P||Q) = Σ p(x) * log(p(x)/q(x))\n\nГде P — истинное распределение,\nQ — модельное.\n\nИспользуется для оценки различий между группами.',
  status: 'unseen'
},
{
  id: 'card-271',
  front: 'Как выглядит формула для оценки causal effect через propensity score matching?',
  back: 'Causal Effect = (Σ w_i*(Y_i*T_i) - w_i*(Y_i*(1-T_i)))\n\nw_i — веса, основанные на пропенсити скоре.\n\nИспользуется для коррекции смещения отбора в неслучайных тестах.',
  status: 'unseen'
},
{
  id: 'card-272',
  front: 'Как рассчитать пропенсити скор?',
  back: 'P(T=1|X) = logistic_regression(X)\n\nЛогистическая регрессия обучается на ковариатах X для предсказания принадлежности к группе T=1.\n\nИспользуется в causal inference.',
  status: 'unseen'
},
{
  id: 'card-273',
  front: 'Как выглядит формула для inverse probability weighting (IPW)?',
  back: 'Effect = (T_i * Y_i / π_i) - ((1-T_i)*Y_i / (1-π_i)), где π_i = P(T=1|X_i)\n\nИспользуется для оценки causal эффекта в наблюдательных исследованиях.',
  status: 'unseen'
},
{
  id: 'card-274',
  front: 'Как рассчитать average treatment effect (ATE)?',
  back: 'ATE = E[Y(1) - Y(0)]\n\nСредний эффект воздействия на всех пользователей. Основная цель causal inference.',
  status: 'unseen'
},
{
  id: 'card-275',
  front: 'Как выглядит формула для conditional average treatment effect (CATE)?',
  back: 'CATE(x) = E[Y(1) - Y(0) | X=x]\n\nУсловный эффект воздействия для пользователей с характеристиками x.',
  status: 'unseen'
},
{
  id: 'card-276',
  front: 'Как рассчитать average treatment effect on the treated (ATT)?',
  back: 'ATT = E[Y(1) - Y(0) | T=1]\n\nСредний эффект воздействия только на тех, кто получил лечение.',
  status: 'unseen'
},
{
  id: 'card-277',
  front: 'Как выглядит формула для doubly robust estimator?',
  back: 'DR = μ̂(x,1) - μ̂(x,0) + [T(y - μ̂(x,1))/π̂(x)] - [(1-T)(y - μ̂(x,0))/(1 - π̂(x))]\n\nСочетает модели outcome и propensity. Устойчив к ошибкам одного из них.',
  status: 'unseen'
},
{
  id: 'card-278',
  front: 'Как рассчитать uplift через метрику Epsilon?',
  back: 'Epsilon = max(|p_A - p_B|) / min(p_A, p_B)\n\nМера относительного отличия. Используется для проверки значимости малых эффектов.',
  status: 'unseen'
},
{
  id: 'card-279',
  front: 'Как рассчитать lift в категориальных данных?',
  back: 'Lift = P(A,B) / (P(A)*P(B))\n\nЕсли Lift > 1 — переменные зависимы. Используется в ассоциативном анализе.',
  status: 'unseen'
},
{
  id: 'card-280',
  front: 'Как выглядит формула для chi-square test?',
  back: 'χ² = Σ[(O_i - E_i)² / E_i], где O_i — наблюдаемые частоты, E_i — ожидаемые.\n\nИспользуется для проверки зависимости между категориальными переменными.',
  status: 'unseen'
},
{
  id: 'card-281',
  front: 'Как рассчитать contingency table?',
  back: 'Таблица вида:\n[[a, b],\n [c, d]]\n\nГде a,b,c,d — количества в каждой ячейке таблицы сопряженности.\n\nИспользуется в хи-квадрат и других тестах.',
  status: 'unseen'
},
{
  id: 'card-282',
  front: 'Как рассчитать expected values в chi-square тесте?',
  back: 'E_ij = (row_total * col_total) / grand_total\n\nДля каждой ячейки таблицы сопряженности.\n\nИспользуется при проверке гипотезы о независимости.',
  status: 'unseen'
},
{
  id: 'card-283',
  front: 'Как выглядит формула для odds ratio через chi-square?',
  back: 'OR = (ad)/(bc), где a,b,c,d — значения в таблице 2×2.\n\nOR > 1 указывает на положительную связь между переменными.',
  status: 'unseen'
},
{
  id: 'card-284',
  front: 'Как рассчитать relative risk через chi-square?',
  back: 'RR = (a/(a+b)) / (c/(c+d))\n\nГде a,b,c,d — значения в таблице 2×2.\n\nRR показывает относительную вероятность события в двух группах.',
  status: 'unseen'
},
{
  id: 'card-285',
  front: 'Как выглядит формула для phi coefficient?',
  back: 'Φ = sqrt(χ² / n), где n — общее число наблюдений.\n\nИспользуется как мера силы связи в таблице 2×2.',
  status: 'unseen'
},
{
  id: 'card-286',
  front: 'Как рассчитать точечный бисериальный корреляционный коэффициент?',
  back: 'r_pb = (M_1 - M_0) * sqrt(pq) / σ_y, где:\n- M_1, M_0 — средние по группам,\n- p, q — доли групп,\n- σ_y — стандартное отклонение метрики.\n\nИспользуется для связи бинарной и непрерывной переменной.',
  status: 'unseen'
},
{
  id: 'card-287',
  front: 'Как рассчитать математическое ожидание в бета-распределении?',
  back: 'E[X] = α / (α + β)\n\nГде α, β — параметры бета-распределения.\n\nИспользуется в байесовских A/B-тестах.',
  status: 'unseen'
},
{
  id: 'card-288',
  front: 'Как рассчитать дисперсию в бета-распределении?',
  back: 'Var(X) = αβ / ((α + β)²(α + β + 1))\n\nГде α, β — параметры распределения.\n\nПоказывает разброс оценки конверсии.',
  status: 'unseen'
},
{
  id: 'card-289',
  front: 'Как выглядит формула для плотности бета-распределения?',
  back: 'f(x) = x^{α-1}(1-x)^{β-1} / B(α, β)\n\nB(α, β) — бета-функция.\n\nОписывает форму априорного и апостериорного распределения.',
  status: 'unseen'
},
{
  id: 'card-290',
  front: 'Как рассчитать posterior mean в бета-биномиальном тесте?',
  back: 'E[p] = (α + k) / (α + β + n), где:\n- k — число успехов,\n- n — число испытаний,\n- α, β — априорные параметры.\n\nИспользуется для получения обновленной оценки конверсии.',
  status: 'unseen'
},
{
  id: 'card-291',
  front: 'Как рассчитать credible interval в бета-распределении?',
  back: 'CI = [Beta.ppf(α_low), Beta.ppf(α_high)]\n\nppf — процентильная функция. Например, для 95% CI: 2.5% и 97.5%.',
  status: 'unseen'
},
{
  id: 'card-292',
  front: 'Как выглядит формула для beta-binomial likelihood?',
  back: 'P(k | n, α, β) = C(n,k) * B(α+k, β+n-k) / B(α, β)\n\nИспользуется для вычисления вероятности наблюдений при заданном априоре.',
  status: 'unseen'
},
{
  id: 'card-293',
  front: 'Как рассчитать Bayes factor в beta-binomial тесте?',
  back: 'BF = P(D|H1) / P(D|H0)\n\nГде H1 — гипотеза о различии,\nH0 — гипотеза об отсутствии различий.\n\nИспользуется для сравнения моделей.',
  status: 'unseen'
},
{
  id: 'card-294',
  front: 'Как рассчитать вероятность того, что A > B в байесовском тесте?',
  back: 'prob = P(p_A > p_B) ≈ mean(samples_A > samples_B)\n\nГде samples_A и samples_B — сэмплы из апостериорных распределений.\n\nИспользуется для принятия решений в байесовском подходе.',
  status: 'unseen'
},
{
  id: 'card-295',
  front: 'Как рассчитать Expected Loss в байесовском A/B-тесте?',
  back: 'EL = E[max(p_A - p_B, 0)]\n\nИспользуется для минимизации ожидаемого ущерба при выборе варианта.',
  status: 'unseen'
},
{
  id: 'card-296',
  front: 'Как выглядит формула для Expected Gain в байесовском тесте?',
  back: 'EG = E[max(p_B - p_A, 0)]\n\nИспользуется для оценки ожидаемой выгоды от выбора B вместо A.',
  status: 'unseen'
},
{
  id: 'card-297',
  front: 'Как рассчитать loss ratio в байесовском тесте?',
  back: 'LossRatio = EL / EG\n\nЕсли < 0.1 — можно принимать решение в пользу B.\n\nИспользуется в бизнес-решениях.',
  status: 'unseen'
},
{
  id: 'card-298',
  front: 'Как рассчитать log-odds в байесовском A/B-тесте?',
  back: 'log_odds = log(P(H1|D)/P(H0|D))\n\nИспользуется для оценки уверенности в гипотезе.',
  status: 'unseen'
},
{
  id: 'card-299',
  front: 'Как выглядит формула для Bayes theorem в A/B-тесте?',
  back: 'P(H|D) = P(D|H) * P(H) / P(D)\n\nГде H — гипотеза о различии,\nD — данные.\n\nОснова байесовского подхода.',
  status: 'unseen'
},
{
  id: 'card-300',
  front: 'Как рассчитать posterior distribution в A/B-тесте?',
  back: 'p_posterior ~ p_prior * likelihood\n\nlikelihood = binomial_probability(data)\np_prior = beta(α, β)\n\nИспользуется для последовательного обновления оценки.',
  status: 'unseen'
},


{
  id: 'card-301',
  front: 'Как рассчитать Z-тест для конверсии на Python?',
  back: 'Пример:\n\nfrom statsmodels.stats.proportion import proportions_ztest\n\n# Пример данных\ncount = [200, 250]  # успехи в группах A и B\nnobs = [1000, 1000]   # размеры выборок\n\nz_stat, p_value = proportions_ztest(count, nobs)\nprint(f"p-value: {p_value}")\n\nИспользуется для проверки значимости различий в конверсии.',
  status: 'unseen'
},
{
  id: 'card-302',
  front: 'Как провести t-тест для средних на Python?',
  back: 'Пример:\n\nfrom scipy.stats import ttest_ind\nimport numpy as np\n\n# Пример данных\na = np.random.normal(100, 10, 1000)\nb = np.random.normal(102, 10, 1000)\n\nt_stat, p_value = ttest_ind(a, b)\nprint(f"p-value: {p_value}")\n\nПодходит для сравнения непрерывных метрик.',
  status: 'unseen'
},
{
  id: 'card-303',
  front: 'Как использовать тест Манна-Уитни в Python?',
  back: 'Пример:\n\nfrom scipy.stats import mannwhitneyu\n\n# Пример данных\na = [1, 2, 3, 4, 5]\nb = [6, 7, 8, 9, 10]\n\nu_stat, p_value = mannwhitneyu(a, b)\nprint(f"p-value: {p_value}")\n\nПолезен при наличии выбросов или не нормальных данных.',
  status: 'unseen'
},
{
  id: 'card-304',
  front: 'Как рассчитать доверительный интервал для конверсии?',
  back: 'Пример:\n\nimport math\n\ndef ci(p, n, z=1.96):\n    se = math.sqrt((p * (1-p)) / n)\n    return (p - z*se, p + z*se)\n\n# Пример: 100 успехов из 1000\np = 0.1\nn = 1000\nprint(ci(p, n))\n\nИспользуется для интерпретации неопределенности.',
  status: 'unseen'
},
{
  id: 'card-305',
  front: 'Как вычислить необходимый объем выборки?',
  back: 'Пример:\n\nfrom statsmodels.stats.power import zt_ind_solve_power\n\n# Уровень конверсии контроля, эффект, мощность\np1 = 0.1\np2 = 0.12\npower = 0.8\n\nn = zt_ind_solve_power(effect_size=(p2 - p1)/math.sqrt(p1*(1-p1)),\n  power=power, alpha=0.05, ratio=1, alternative=two-sided)\nprint(f"Необходимый размер выборки: {int(n)}")\n\nПомогает спланировать длительность теста.',
  status: 'unseen'
},
{
  id: 'card-306',
  front: 'Как рассчитать относительное изменение конверсии?',
  back: 'Пример:\n\nconv_a = 0.1\nconv_b = 0.12\nrel_change = (conv_b - conv_a) / conv_a * 100\nprint(f"Относительное изменение: {rel_change:.2f}%")\n\nДля бизнес-интерпретации результатов.',
  status: 'unseen'
},
{
  id: 'card-307',
  front: 'Как визуализировать распределение конверсий в группах?',
  back: 'Пример:\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.histplot(data=[group_a, group_b], bins=20, kde=True)\nplt.xlabel("Конверсия")\nplt.title("Распределение конверсий")\nplt.show()\n\nПомогает увидеть различия визуально.',
  status: 'unseen'
},
{
  id: 'card-308',
  front: 'Как создать таблицу сопряженности в SQL?',
  back: 'Пример:\n\nSELECT \n  treatment,\n  SUM(CASE WHEN converted = 1 THEN 1 ELSE 0 END) AS success,\n  COUNT(*) AS total\nFROM experiments\nGROUP BY treatment;\n\nИспользуется для подготовки данных к анализу.',
  status: 'unseen'
},
{
  id: 'card-309',
  front: 'Как рассчитать p-value в SQL через Z-тест?',
  back: 'SQL сам не поддерживает Z-тест напрямую, но можно экспортировать данные и обработать в Python.\n\nSELECT \n  treatment,\n  SUM(conversion) AS successes,\n  COUNT(*) AS trials\nFROM experiments\nGROUP BY treatment;',
  status: 'unseen'
},
{
  id: 'card-310',
  front: 'Как рассчитать uplift с помощью T-learner?',
  back: 'Пример:\n\nfrom sklearn.linear_model import LogisticRegression\n\n# Обучение моделей\nmodel_control = LogisticRegression().fit(X_control, y_control)\nmodel_treatment = LogisticRegression().fit(X_treatment, y_treatment)\n\n# Оценка uplift\nuplift = model_treatment.predict_proba(X_test)[:,1] - model_control.predict_proba(X_test)[:,1]\n\nИспользуется для моделирования индивидуального эффекта.',
  status: 'unseen'
},
{
  id: 'card-311',
  front: 'Как использовать библиотеку `causalml` для uplift моделирования?',
  back: 'Пример:\n\nfrom causalml.inference.tree import UpliftTreeClassifier\n\nmodel = UpliftTreeClassifier()\nmodel.fit(X.values, treatment=treatment.values, y=y.values)\nuplift_scores = model.predict(X)\n\nИспользуется для анализа причинного эффекта.',
  status: 'unseen'
},
{
  id: 'card-312',
  front: 'Как построить Qini curve?',
  back: 'Пример:\n\nfrom causalml.metrics import plot_qini_curve\n\nplot_qini_curve(y_true, uplift_scores)\n\nВизуализирует эффективность uplift-модели.',
  status: 'unseen'
},
{
  id: 'card-313',
  front: 'Как рассчитать AUUC?',
  back: 'Пример:\n\nfrom causalml.metrics import auuc_score\n\nscore = auuc_score(uplift_scores, y_true, treatment)\nprint(f"AUUC: {score}")\n\nМера качества uplift-модели.',
  status: 'unseen'
},
{
  id: 'card-314',
  front: 'Как рассчитать пропенсити скор?',
  back: 'Пример:\n\nfrom sklearn.linear_model import LogisticRegression\n\npropensity_model = LogisticRegression()\npropensity_model.fit(X, treatment)\npropensity_scores = propensity_model.predict_proba(X)[:,1]\n\nИспользуется в causal inference.',
  status: 'unseen'
},

{
  id: 'card-316',
  front: 'Как запустить байесовский A/B-тест с Beta-распределением?',
  back: 'Пример:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Априорные параметры\nalpha_a, beta_a = 1, 1\nalpha_b, beta_b = 1, 1\n\n# Данные\nsuccess_a, trials_a = 100, 1000\nsuccess_b, trials_b = 120, 1000\n\n# Апостериорные распределения\nposterior_a = np.random.beta(alpha_a + success_a, beta_a + trials_a - success_a, 10000)\nposterior_b = np.random.beta(alpha_b + success_b, beta_b + trials_b - success_b, 10000)\n\nprob = (posterior_b > posterior_a).mean()\nprint(f"P(B > A): {prob:.2f}")\n\nИспользуется в байесовском подходе.',
  status: 'unseen'
},
{
  id: 'card-317',
  front: 'Как рассчитать credible interval в байесовском тесте?',
  back: 'Пример:\n\nimport numpy as np\n\nsamples = np.random.beta(100, 900, 10000)\nci = np.percentile(samples, [2.5, 97.5])\nprint(f"95% CI: {ci}")\n\nИспользуется вместо классического доверительного интервала.',
  status: 'unseen'
},
{
  id: 'card-318',
  front: 'Как визуализировать апостериорные распределения в байесовском A/B-тесте?',
  back: 'Пример:\n\nimport seaborn as sns\n\nsns.kdeplot(posterior_a, label="A")\nsns.kdeplot(posterior_b, label="B")\nplt.legend()\nplt.title("Апостериорные распределения")\nplt.show()\n\nДля наглядной интерпретации.',
  status: 'unseen'
},
{
  id: 'card-319',
  front: 'Как рассчитать Expected Loss в байесовском тесте?',
  back: 'Пример:\n\nloss = np.mean(np.maximum(posterior_a - posterior_b, 0))\nprint(f"Expected Loss: {loss:.4f}")\n\nДля принятия решений с учетом рисков.',
  status: 'unseen'
},
{
  id: 'card-320',
  front: 'Как рассчитать Bayes Factor?',
  back: 'Пример:\n\nimport scipy.special as scs\n\ndef bayes_factor(success_a, trials_a, success_b, trials_b):\n    B = lambda a, b: scs.betaln(a, b)\n    log_B_ab = B(success_a + 1, trials_a - success_a + 1) + B(success_b + 1, trials_b - success_b + 1)\n    log_B_0 = B(1, 1) * 2\n    return np.exp(log_B_0 - log_B_ab)\n\nbf = bayes_factor(100, 1000, 120, 1000)\nprint(f"Bayes Factor: {bf:.2f}")\n\nДля сравнения гипотез в байесовском подходе.',
  status: 'unseen'
},
{
  id: 'card-321',
  front: 'Как использовать `pymc` для байесовского A/B-тестирования?',
  back: 'Пример:\n\nimport pymc3 as pm\n\nwith pm.Model() as model:\n    p_a = pm.Beta(p_a, alpha=1, beta=1)\n    p_b = pm.Beta(p_b, alpha=1, beta=1)\n\n    obs_a = pm.Bernoulli(obs_a, p=p_a, observed=data_a)\n    obs_b = pm.Bernoulli(obs_b, p=p_b, observed=data_b)\n\n    trace = pm.sample(1000)\n\npm.plot_posterior(trace)\n\nДля продвинутого байесовского анализа.',
  status: 'unseen'
},


{
  id: 'card-323',
  front: 'Как использовать `statsmodels` для ANOVA?',
  back: 'Пример:\n\nfrom statsmodels.formula.api import ols\nfrom statsmodels.stats.anova import anova_lm\n\nmodel = ols("metric ~ group", data=df).fit()\nanova_table = anova_lm(model)\nprint(anova_table)\n\nДля сравнения более чем двух вариантов.',
  status: 'unseen'
},
{
  id: 'card-324',
  front: 'Как использовать `sklearn` для регрессионной коррекции?',
  back: 'Пример:\n\nfrom sklearn.linear_model import LinearRegression\n\nX = df[["treatment", "age", "gender"]]\ny = df["conversion"]\n\nmodel = LinearRegression().fit(X, y)\neffect = model.coef_[0]\nprint(f"Оценка эффекта: {effect:.4f}")\n\nДля повышения точности оценки эффекта.',
  status: 'unseen'
},


{
  id: 'card-327',
  front: 'Как использовать `causalml` для doubly robust estimator?',
  back: 'Пример:\n\nfrom causalml.inference.meta import LRSRegressor\n\nlr = LRSRegressor()\nuplift_lr = lr.fit_predict(X, treatment, y)\nprint(uplift_lr)\n\nДля более надежной оценки causal эффекта.',
  status: 'unseen'
},
{
  id: 'card-328',
  front: 'Как использовать `lightgbm` для uplift моделирования?',
  back: 'Пример:\n\nfrom lightgbm import LGBMRegressor\n\nmodel = LGBMRegressor()\nmodel.fit(X_train, y_train, sample_weight=treatment_train)\nuplift = model.predict(X_test)\n\nДля обучения uplift-моделей на больших данных.',
  status: 'unseen'
},
{
  id: 'card-329',
  front: 'Как использовать `xgboost` для uplift моделирования?',
  back: 'Пример:\n\nfrom xgboost import XGBRegressor\n\nmodel = XGBRegressor()\nmodel.fit(X_train, y_train, sample_weight=treatment_train)\nuplift = model.predict(X_test)\n\nЕще один вариант для uplift-обучения.',
  status: 'unseen'
},

{
  id: 'card-331',
  front: 'Как использовать `shap` для интерпретации uplift-модели?',
  back: 'Пример:\n\nimport shap\n\nexplainer = shap.Explainer(model)\nshap_values = explainer(X_test)\nshap.summary_plot(shap_values, X_test)\n\nДля понимания, какие факторы влияют на uplift.',
  status: 'unseen'
},
{
  id: 'card-332',
  front: 'Как использовать `eli5` для интерпретации uplift-модели?',
  back: 'Пример:\n\nimport eli5\n\neli5.show_weights(model)\n\nДля простой визуализации важности признаков.',
  status: 'unseen'
},
{
  id: 'card-333',
  front: 'Как использовать `sklearn` для bootstrap?',
  back: 'Пример:\n\nfrom sklearn.utils import resample\n\nbootstraps = []\nfor _ in range(1000):\n    sample = resample(data, replace=True)\n    bootstraps.append(np.mean(sample))\n\nconf_interval = np.percentile(bootstraps, [2.5, 97.5])\nprint(conf_interval)\n\nДля оценки неопределенности без предположений о распределении.',
  status: 'unseen'
},
{
  id: 'card-334',
  front: 'Как использовать `bootstrap` из `scipy`?',
  back: 'Пример:\n\nfrom scipy.stats import bootstrap\n\nres = bootstrap((data,), statistic=np.mean, n_resamples=1000)\nprint(res.confidence_interval)\n\nДля автоматической оценки доверительных интервалов.',
  status: 'unseen'
},

{
  id: 'card-341',
  front: 'Как использовать `google colab` для A/B-тестов?',
  back: 'Пример:\n\nfrom google.colab import files\nuploaded = files.upload()\ndf = pd.read_csv("data.csv")\n\nДля работы без локальной установки ПО.',
  status: 'unseen'
},
{
  id: 'card-342',
  front: 'Как использовать `dask` для больших данных?',
  back: 'Пример:\n\nimport dask.dataframe as dd\ndf = dd.read_csv("big_data.csv")\n\nДля обработки данных, которые не помещаются в память.',
  status: 'unseen'
},


		   ];


            let currentCardIndex = 0;
            let shuffledOrder = [];
            let isShuffled = false;

            let currentDeck = []; // Карточки, которые сейчас отображаются
            let isReviewMode = false;

            let timerInterval = null;
            let secondsElapsed = 0;


            // --- Timer Functions ---
            function formatTime(seconds) {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = seconds % 60;
                const padded = [m, s].map(val => val.toString().padStart(2, '0'));
                if (h > 0) {
                    return `${h.toString().padStart(2, '0')}:${padded[0]}:${padded[1]}`;
                }
                return `${padded[0]}:${padded[1]}`;
            }

            function startTimer() {
                if (timerInterval) clearInterval(timerInterval);
                timerDisplay.textContent = formatTime(secondsElapsed);
                timerInterval = setInterval(() => {
                    secondsElapsed++;
                    timerDisplay.textContent = formatTime(secondsElapsed);
                }, 1000);
            }

            function stopTimer() {
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
            }

            function resetTimer() {
                stopTimer();
                secondsElapsed = 0;
                timerDisplay.textContent = formatTime(secondsElapsed);
            }


            // --- Card Display and Navigation ---

            function getCardData(index) {
                const sourceCards = (isShuffled && !isReviewMode && shuffledOrder && shuffledOrder.length === cards.length) ?
                                    shuffledOrder.map(i => cards[i]) :
                                    currentDeck;

                if (sourceCards.length === 0) {
                    return null;
                }

                const actualIndex = index % sourceCards.length;
                const wrappedIndex = actualIndex < 0 ? actualIndex + sourceCards.length : actualIndex;

                if (isShuffled && !isReviewMode && shuffledOrder && shuffledOrder.length === cards.length) {
                     const originalIndex = shuffledOrder[wrappedIndex];
                     return cards[originalIndex];
                 } else {
                     return currentDeck[wrappedIndex];
                 }
            }

            function displayCard(index) {
                // Проверяем, есть ли карточки в текущей колоде
                if (currentDeck.length === 0) {
                    cardFrontText.textContent = isReviewMode ? "Нет карточек для повторения." : "Нет карточек.";
                    cardBackText.textContent = isReviewMode ? "Добавьте карточки или отметьте их для повторения." : "Добавьте карточки.";
                    flashcard.classList.remove('is-flipped');
                    prevButton.disabled = true;
                    nextButton.disabled = true;
                    actionButtons.forEach(btn => btn.style.visibility = 'hidden');
                    shuffleButton.disabled = true;
                    toggleReviewModeButton.disabled = true;
                    searchButton.disabled = true; // Disable search button
                    currentCardIndex = 0;
                    updateStats();
                    return;
                }

                // Включаем кнопки, если они были отключены
                prevButton.disabled = false;
                nextButton.disabled = false;
                actionButtons.forEach(btn => btn.style.visibility = 'visible');
                shuffleButton.disabled = isReviewMode;
                toggleReviewModeButton.disabled = false;
                searchButton.disabled = false; // Enable search button


                // Корректируем индекс, чтобы он оставался в пределах текущей колоды (циклическая навигация)
                currentCardIndex = index;
                if (currentCardIndex < 0) currentCardIndex = currentDeck.length - 1;
                if (currentCardIndex >= currentDeck.length) currentCardIndex = 0;


                const card = getCardData(currentCardIndex);


                if (card) {
                    cardFrontText.textContent = card.front;
                    cardBackText.textContent = card.back;
                } else {
                    console.error("[displayCard] getCardData returned null.");
                    cardFrontText.textContent = "Ошибка загрузки карточки";
                    cardBackText.textContent = "Ошибка загрузки карточки";
                }

                flashcard.classList.remove('is-flipped'); // <<< Убедимся, что всегда показываем лицевую сторону следующей карточки

                updateStats();
            }

            function flipCard() {
                if (currentDeck.length === 0) return;
                flashcard.classList.toggle('is-flipped');
            }

            function nextCard() {
                if (currentDeck.length === 0) {
                    return;
                }
                const nextIndex = (currentCardIndex + 1) % currentDeck.length;
                displayCard(nextIndex);
            }

            function prevCard() {
                if (currentDeck.length === 0) {
                    return;
                }
                const prevIndex = (currentCardIndex - 1 + currentDeck.length) % currentDeck.length;
                displayCard(prevIndex);
            }

            function shuffleCards() {
                if (cards.length === 0 || isReviewMode) {
                    return;
                }

                isReviewMode = false;
                shuffleButton.disabled = false;
                // Текст кнопки "Повторить" будет обновлен в updateStats

                shuffledOrder = Array.from({ length: cards.length }, (_, i) => i);

                // Алгоритм перемешивания Фишера-Йетса
                for (let i = shuffledOrder.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledOrder[i], shuffledOrder[j]] = [shuffledOrder[j], shuffledOrder[i]]; // меняем местами
                }
                isShuffled = true;
                currentDeck = cards; // currentDeck все еще полная колода
                currentCardIndex = 0;
                displayCard(currentCardIndex); // Обновляем дисплей
            }

            // --- Режим повторения ---
            function toggleReviewMode() {
                if (cards.length === 0) {
                    return;
                }

                stopTimer();

                if (!isReviewMode) { // Переключаемся в режим повторения
                    const reviewCards = cards.filter(card => card.status === 'review');
                    if (reviewCards.length === 0) {
                        alert("Нет карточек, требующих повторения.");
                        startTimer(); // Возобновляем таймер
                        return;
                    }
                    isReviewMode = true;
                    currentDeck = reviewCards; // Теперь currentDeck только для повторения
                    shuffleButton.disabled = true;
                    toggleReviewModeButton.textContent = `Показать все (${cards.length})`; // Показываем общее кол-во при выходе
                    currentCardIndex = 0; // Начинаем сначала колоды повторения
                } else { // Переключаемся обратно в обычный режим
                    isReviewMode = false;
                    currentDeck = cards; // Возвращаемся к полной колоде
                    isShuffled = false; // Сбрасываем перемешивание при выходе из режима повторения
                    shuffledOrder = Array.from({ length: cards.length }, (_, i) => i); // Возвращаем исходный порядок
                    shuffleButton.disabled = false;
                    const reviewCount = cards.filter(card => card.status === 'review').length;
                    toggleReviewModeButton.textContent = `Повторить (${reviewCount})`; // Обновляем счетчик
                    currentCardIndex = 0; // Начинаем сначала полной колоды
                }

                displayCard(currentCardIndex); // Отображаем первую карточку новой колоды
                startTimer();
            }


            // --- Status ---
            function markCard(status) {
                if (currentDeck.length === 0 || !flashcard.classList.contains('is-flipped')) {
                    return;
                }

                const currentCardOnDisplay = getCardData(currentCardIndex);

                if (!currentCardOnDisplay) {
                    console.error("[markCard] Could not get card data for current index.");
                    return;
                }

                // Находим эту карточку в оригинальном массиве cards, чтобы обновить ее статус там
                const originalCard = cards.find(c => c.id === currentCardOnDisplay.id);

                if (originalCard) {
                    const oldStatus = originalCard.status;
                    originalCard.status = status; // Обновляем статус в оригинальном массиве


                    // Если мы в режиме повторения И статус изменился с 'review' на что-то другое,
                    // удаляем карточку из currentDeck
                    if (isReviewMode && oldStatus === 'review' && status !== 'review') {
                        currentDeck = currentDeck.filter(c => c.id !== originalCard.id);

                        // Корректируем currentCardIndex, если он стал невалидным после удаления
                        if (currentDeck.length === 0) {
                            currentCardIndex = 0; // Колода стала пустой
                        } else if (currentCardIndex >= currentDeck.length) {
                            currentCardIndex = currentDeck.length - 1; // Adjust index if it's now out of bounds
                        } else {
                            // Индекс остался валидным, остаемся на нем, displayCard покажет следующую по кругу
                        }

                    } else {
                        // Не в режиме повторения ИЛИ статус остался 'review'
                        // В этих случаях мы ДОЛЖНЫ перейти к следующей карточке в текущей колоде.
                        currentCardIndex = (currentCardIndex + 1) % currentDeck.length; // ИСПРАВЛЕНИЕ ПЕРЕХОДА!
                    }


                    updateStats(); // Обновляем статистику (основываясь на полном массиве cards)
                    checkCompletion(); // Проверяем, все ли изучено

                    // Переходим к следующей карточке в текущей (возможно, уменьшенной) колоде
                    // displayCard сам скорректирует индекс, если он вышел за пределы,
                    // и покажет лицевую сторону.
                    displayCard(currentCardIndex); // displayCard отобразит карточку по новому индексу и покажет лицевую сторону
                } else {
                    console.error("[markCard] Original card not found in 'cards' array.");
                }
            }

            // --- Statistics ---
            function updateStats() {
                const total = cards.length;
                const learnedCount = cards.filter(card => card.status === 'learned').length;
                const reviewCount = cards.filter(card => card.status === 'review').length;
                const unseenCount = cards.filter(card => card.status === 'unseen').length;
                const seenCount = total - unseenCount;

                // Обновляем сводную статистику в хедере
                cardCountsDisplay.textContent = `И: ${learnedCount}, П: ${reviewCount}, В: ${total}`;


                // Обновляем подробную статистику в блоке статистики
                totalCardsStats.textContent = total;
                learnedStats.textContent = learnedCount;
                reviewStats.textContent = reviewCount;
                seenStats.textContent = seenCount;

                // Обновляем текст кнопки "Повторить" со актуальным числом карточек на повторении
                // В режиме "Показать все" текст уже другой
                if (!isReviewMode) {
                    toggleReviewModeButton.textContent = `Повторить (${reviewCount})`;
                }
            }

            function toggleStatsVisibility() {
                const isHidden = statsArea.style.display === 'none';
                statsArea.style.display = isHidden ? 'block' : 'none';
                toggleStatsButton.textContent = isHidden ? 'Скрыть статистику' : 'Показать статистику';
            }

            // --- Completion Logic ---
            function checkCompletion() {
                const allLearned = cards.length > 0 && cards.every(card => card.status === 'learned');
                if (allLearned) {
                    showCompletionMessage();
                }
            }

            function showCompletionMessage() {
                stopTimer();
                finalTimeDisplay.textContent = formatTime(secondsElapsed);
                completionModal.classList.add('visible');
                document.body.style.overflow = 'hidden';
            }

            function hideCompletionMessage() {
                completionModal.classList.remove('visible');
                document.body.style.overflow = '';
            }

            // --- Reset Functionality ---
            function resetApp() {
                // Сбрасываем статусы всех карточек на 'unseen'
                // Создаем НОВЫЙ массив карточек с исходными статусами
                cards = cards.map(card => ({ ...card, status: 'unseen' })); // Reset status to unseen

                // Сбрасываем все связанные состояния
                isReviewMode = false;
                isShuffled = false;
                currentDeck = cards; // Возвращаемся к полной колоде
                shuffledOrder = Array.from({ length: cards.length }, (_, i) => i); // Сбрасываем порядок перемешивания
                currentCardIndex = 0;
                resetTimer(); // Сбрасываем и запускаем таймер заново

                // Обновляем UI (текст кнопок, статистика)
                updateStats(); // updateStats обновит текст кнопки "Повторить" и сводную статистику
                shuffleButton.disabled = false; // Включена по умолчанию
                toggleReviewModeButton.disabled = false; // Включена по умолчанию
                searchButton.disabled = false; // Enable search button


                // Перемешиваем и отображаем первую карточку
                shuffleCards(); // shuffleCards вызовет displayCard
            }

            // --- "Начать заново" после завершения ---
            function startOverFromCompletion() {
                hideCompletionMessage(); // Скрываем модальное окно
                resetApp(); // Вызываем основную функцию сброса
            }

            // --- Theme Toggle ---
            function toggleTheme() {
                document.body.classList.toggle('dark-mode');
            }

            // --- Search Functionality ---
            function searchCardText() {
                let textToSearch = '';
                // Check which face is currently visible
                if (flashcard.classList.contains('is-flipped')) {
                    textToSearch = cardBackText.textContent;
                } else {
                    textToSearch = cardFrontText.textContent;
                }

                if (textToSearch) {
                    // Encode the text for the URL
                    const encodedText = encodeURIComponent(textToSearch);
                    // Construct the Google search URL
                    const googleSearchUrl = `https://www.google.com/search?q=${encodedText}`;
                    // Open in a new tab
                    window.open(googleSearchUrl, '_blank');
                }
            }


            // --- Event Listeners ---
            flashcard.addEventListener('click', flipCard);

            // Навигация по кругу в текущей колоде
            prevButton.addEventListener('click', prevCard);
            nextButton.addEventListener('click', nextCard);

            shuffleButton.addEventListener('click', shuffleCards); // Слушатель для кнопки внизу
            toggleReviewModeButton.addEventListener('click', toggleReviewMode); // Слушатель для кнопки внизу
            themeToggleButton.addEventListener('click', toggleTheme);
            toggleStatsButton.addEventListener('click', toggleStatsVisibility);
            resetAppButton.addEventListener('click', resetApp); // Слушатель для кнопки внизу
            searchButton.addEventListener('click', searchCardText); // Add event listener for the search button


            actionButtons.forEach(button => {
                button.addEventListener('click', (event) => {
                    event.stopPropagation(); // Предотвращаем переворот карточки
                    markCard(button.dataset.status);
                });
            });

            // Слушатель для кнопки "Начать заново" в модальном окне
            startOverButton.addEventListener('click', startOverFromCompletion);

            // Закрытие модального окна при клике вне контента
            completionModal.addEventListener('click', (event) => {
                if (event.target === completionModal) {
                    // При желании, можно добавить закрытие по клику вне:
                    // hideCompletionMessage();
                }
            });


            // --- Keyboard Navigation ---
            document.addEventListener('keydown', (event) => {
                // Если модальное окно видимо, обрабатываем только Enter/Space
                if (completionModal.classList.contains('visible')) {
                    if (event.code === 'Enter' || event.code === 'Space') {
                        event.preventDefault();
                        startOverButton.click(); // Эмулируем клик по кнопке
                    }
                    return; // Игнорируем другие нажатия клавиш
                }

                // Навигация (стрелки влево/вправо)
                if (event.code === 'ArrowLeft') {
                    event.preventDefault();
                    prevCard();
                } else if (event.code === 'ArrowRight') {
                    event.preventDefault();
                    nextCard();
                }
                // Переворот (Пробел)
                else if (event.code === 'Space') {
                    event.preventDefault(); // Предотвращаем прокрутку страницы
                    flipCard();
                }
                // Добавить обработку клавиш 1, 2 и т.д. для отметки статуса, если нужно
            });


            // --- Initialization ---
            // Инициализация состояний по умолчанию при загрузке страницы
            // Массив cards уже определен выше с начальными статусами
            cards = cards;

            currentDeck = cards; // По умолчанию показываем все
            shuffledOrder = Array.from({ length: cards.length }, (_, i) => i);
            isShuffled = false;
            isReviewMode = false;
            currentCardIndex = 0;
            secondsElapsed = 0; // Таймер с 0 при старте
            statsArea.style.display = 'none';
            toggleStatsButton.textContent = 'Показать статистику';
            shuffleButton.disabled = false; // Включена по умолчанию
            toggleReviewModeButton.disabled = false; // Включена по умолчанию
            searchButton.disabled = false; // Enable search button initially


            displayCard(currentCardIndex); // Отображаем начальную карточку (она вызовет updateStats)
            startTimer(); // Запускаем таймер
            checkCompletion(); // Проверяем завершение (вероятно, не сработает при старте без сохранения)
        });
    </script>
</body>
</html>
